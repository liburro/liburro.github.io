<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>[专项]-python</title>
      <link href="/2128/06/28/special-python/"/>
      <url>/2128/06/28/special-python/</url>
      <content type="html"><![CDATA[<p>本文主要记录了python的相关编程笔记。本文主要以python2.7为主，后面会增加python2与python3的差异补充说明。</p><p>本文实际发布时间是2018-06-25，为了置顶，所以修改了发布时间为将来的某个时间。</p><a id="more"></a><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>字典是一种键值对的方式表示的数据类型，是key-value的方式存在的，key是唯一的，如果后期重新给这个key赋值，前面的值是被覆盖掉的， python的字典是<strong>无序</strong>的。</p><blockquote><p>注意， 如果使用<code>{}</code>的方式表示，需要与set类型进行区分，如果<code>{}</code>里面没有内容，那么产生的是一个字典，如果<code>{1, 2, 3}</code>这种方式，产生的是一个集合(set)。</p></blockquote><h3 id="判断字典是否包含某个key"><a href="#判断字典是否包含某个key" class="headerlink" title="判断字典是否包含某个key"></a>判断字典是否包含某个key</h3><p>使用<code>in</code>来代替函数<code>has_key</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'b'</span> <span class="keyword">in</span> testdict:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'字典中包含b这个key'</span></span><br></pre></td></tr></table></figure><h3 id="遍历字典的key"><a href="#遍历字典的key" class="headerlink" title="遍历字典的key"></a>遍历字典的key</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> testdict:</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><h3 id="遍历字典的value"><a href="#遍历字典的value" class="headerlink" title="遍历字典的value"></a>遍历字典的value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> testdict.itervalues():</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><blockquote><p>注意， python3的字典对象没有<code>iterxxx</code>类似的的函数了，比如<code>itervalues()</code>被替换为<code>values()</code>了，<code>values()</code>在python2里面也存在，但是python3里面的<code>values()</code>行为和python2里面的<code>itervalues()</code>行为类似了。</p></blockquote><h3 id="获取key对应的value"><a href="#获取key对应的value" class="headerlink" title="获取key对应的value"></a>获取key对应的value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict[<span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict[<span class="string">'c'</span>] <span class="comment">#其中这里会报错，因为字典testdict中没有c这个key。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict.get(<span class="string">'a'</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict.get(<span class="string">'c'</span>, <span class="number">3</span>) <span class="comment">#这里会输出3</span></span><br></pre></td></tr></table></figure><p>上面的两种方式区别： 方式一是直接通过<code>[]</code>获取，那么这个key就必须存在于字典中，如果不存在，会报错，方式二是通过函数<code>get(key, value=None)</code>来获取，其中第一个参数是需要获取的key，如果这个key存在于字典中，那么返回这个key对应的实际的vlaue，否则返回第二个参数的值，默认是<code>None</code>。</p><h3 id="setdefault"><a href="#setdefault" class="headerlink" title="setdefault"></a>setdefault</h3><p><code>setdefault(key, value=None)</code>是一个函数，它的作用是，如果key存在于字典中，则返回字典的实际值，如果不存在，会给字典增加一个key，并且设置对应的值为value，默认是<code>None</code>，并且返回这个值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict.setdefault(<span class="string">'a'</span>) <span class="comment">#这里输出1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict.setdefault(<span class="string">'c'</span>) <span class="comment">#这里输出None,因为'c'不在testdict中，并且没有传递第二个参数，使用None，并且现在testdict变成了 &#123;'a': 1, 'b':2, 'c': None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> testdict.setdefault(<span class="string">'d'</span>, <span class="number">4</span>) <span class="comment">#这里输出4，并且testdict变成了 &#123;'a': 1, 'b':2, 'c': None, 'd': 4&#125;</span></span><br></pre></td></tr></table></figure><h3 id="同时遍历key和vlaue"><a href="#同时遍历key和vlaue" class="headerlink" title="同时遍历key和vlaue"></a>同时遍历key和vlaue</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testdict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> testdict.iteritems():</span><br><span class="line">    <span class="keyword">print</span> key, value</span><br></pre></td></tr></table></figure><blockquote><p>注意， python3里面的<code>items</code>函数类似python2里面的<code>iteritems</code>函数。</p></blockquote><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>我们知道很多操作步骤完成后，需要有一个清理的动作，比如使用<code>open()</code>打开了一个文件后，不管是读还是写的操作完成后，我们都需要调用<code>close()</code>关闭这个资源。<br>有下面几种操作方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fp = open(&apos;file&apos;, &apos;r&apos;)</span><br><span class="line">fp.read()</span><br><span class="line">fp.close()</span><br></pre></td></tr></table></figure><p>上面一种情况，如果在<code>read()</code>部分抛出了异常，那么<code>close</code>是不会执行的，也就是不能释放资源，这是很危险的动作。那么引申出了下面的用try来捕获异常的操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fp = open(&apos;file&apos;, &apos;r&apos;)</span><br><span class="line">try:</span><br><span class="line">    fp.read()</span><br><span class="line">except Exception as e:</span><br><span class="line">    print e.message</span><br><span class="line">finally:</span><br><span class="line">    if fp:</span><br><span class="line">        fp.close()</span><br></pre></td></tr></table></figure><p>其中finally里面的内容是一定会被执行的，也就是一定会释放资源。</p><p>其实python提供了上下文管理器对这个操作进行更为方便的管理，对应的就是<code>with</code>语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(&apos;file&apos;, &apos;r&apos;) as fp:</span><br><span class="line">    fp.read()</span><br></pre></td></tr></table></figure><p>通过<code>with</code>语句，会自动的关闭掉对应的资源。</p><h3 id="实现自己的上下文管理器"><a href="#实现自己的上下文管理器" class="headerlink" title="实现自己的上下文管理器"></a>实现自己的上下文管理器</h3><p>python里面的通过类的方式来实现上下文管理器的。设计到两个method: <code>__exit__ __enter__</code>，通过<code>with</code>调用我们的类后，会执行到<code>__enter__</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class TestWith(object):</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        return self</span><br><span class="line">        </span><br><span class="line">    def __exit__(self, exc_type, exc_value, tb):</span><br><span class="line">        #参数exc_type, exc_value, tb分别表示异常类型，异常的值，跟踪对象，如果没有异常发生，默认都是None</span><br><span class="line">        pass</span><br><span class="line">        </span><br><span class="line">    def fun(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure><p>假如有上面一个类，那么我们可以通过如下的方式进行调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with TestWith() as test:</span><br><span class="line">    test.func()</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意1</strong>， 如果类有<code>__init__</code>，一定会先执行这个，在执行<code>__enter__</code>， 也就是执行顺序是 <code>__init__</code> –&gt; <code>__enter__</code> –&gt; <code>with</code>里面的语句 –&gt; <code>__exit__</code>。<br><strong>注意2</strong>， 如果在<code>__init__</code>中抛出了异常，那么是不会继续往后执行的<br><strong>注意3</strong>， 默认情况下，如果在<code>with</code>里面有异常发生， <code>__exit__</code>会捕捉到一场，并且三个参数对应了异常的各个值， 并且这个异常会继续抛出， 但是如果<code>__exit__</code>里面返回了真值，<br>那么这个异常会被抑制，不会向上抛出。<br><strong>注意4</strong>， 就算在<code>with</code>里面使用了<code>return</code>语句，<code>__exit__</code>仍然会被执行。</p></blockquote><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>python里面可以使用<code>@</code>语法糖来包装一个函数或者类。</p><p>先来看一个优先级规则: 假如fun是一个函数，没有参数，返回的也是一个函数，那么<code>fun()()</code>这种形式就是<code>fun</code>和第一个<code>()</code>结合，也就是<code>fun()</code>这是一个函数调用，返回的是一个函数，比如fun1，<br>这个时候就变成了<code>fun1()</code>，这里的<code>()</code>是<code>fun()()</code>里面的第二个括号，也是一个函数调用的关系。</p><p>形式大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    return f</span><br><span class="line">    </span><br><span class="line">@fun1</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>其中<code>fun1</code>只接收1个参数，这个参数是一个函数，在<code>test</code>函数上面使用了<code>@fun1</code>，那么我们在调用<code>test()</code>的时候，实际是调用了<code>fun1(test)()</code>。</p><p>那么上个例子中，实际调用<code>fun1(test)</code>返回的是一个函数，就是<code>test</code>本身，所以没有什么区别，如果返回的是另外的函数，那么当你调用<code>test()</code>的时候，函数的行为就变为新的的。</p><p>上一个例子打印的是hehe， 下面的例子打印的就是haha了。因为在<code>fun1</code>中，返回的是<code>inf</code>这个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    def inf():</span><br><span class="line">        print &apos;haha&apos;</span><br><span class="line">    return inf</span><br><span class="line">    </span><br><span class="line">@fun1</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>如果在<code>@</code>中，类似<code>@fun1</code>这种形式，那么证明<code>fun1</code>就是真正的装饰器，如果使用了<code>@fun1()</code>这种形式(可以带参数)，那么证明<code>fun1</code>并不是真正的装饰器，记住一点，装饰器函数只接收一个参数，就是被修饰的函数对象。</p><p>比如下面的例子会报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    def inf():</span><br><span class="line">        print &apos;haha&apos;</span><br><span class="line">    return inf</span><br><span class="line">    </span><br><span class="line">@fun1()</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>因为使用了<code>@fun1()</code>的方式，实际的调用情况是<code>fun1()(test)()</code>，首先，<code>fun1</code>需要1个参数，这里没有传递，那么这里会报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    def inf():</span><br><span class="line">        print &apos;haha&apos;</span><br><span class="line">    return inf</span><br><span class="line">    </span><br><span class="line">@fun1(1)</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>这个同理，调用方式为<code>fun1(1)(test)()</code>，首先<code>fun1(1)</code>返回的是<code>inf</code>，这个不接受任何参数，所以报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    def inf(x):</span><br><span class="line">        print &apos;haha&apos;</span><br><span class="line">    return inf</span><br><span class="line">    </span><br><span class="line">@fun1(1)</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>这个同理，调用方式为<code>fun1(1)(test)()</code>，首先<code>fun1(1)</code>返回的是<code>inf</code>，接收一个参数，返回空(因为inf里面只有一句print，没有返回，python默认返回None)，报错。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def fun1(f):</span><br><span class="line">    def inf(x):</span><br><span class="line">        print &apos;haha&apos;</span><br><span class="line">        return x</span><br><span class="line">    return inf</span><br><span class="line">    </span><br><span class="line">@fun1(1)</span><br><span class="line">def test():</span><br><span class="line">    print &apos;hehe&apos;</span><br><span class="line">    </span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>这个就对了，调用方式为<code>fun1(1)(test)()</code>，首先<code>fun1(1)</code>返回的是<code>inf</code>，接收一个参数，返回x，这个x就是我们的原函数test，这里会打印haha然后打印hehe。</p><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><h3 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h3><h4 id="os-path-dirname"><a href="#os-path-dirname" class="headerlink" title="os.path.dirname"></a>os.path.dirname</h4><p>这个函数接收一个路径作为参数，并且返回这个参数所在的目录。</p><p>比如<code>os.path.dirname(&quot;C:\test\file.txt&quot;)</code> 会返回 C:\test，取得了file.txt文件的目录名。</p><blockquote><p>注意，这个函数返回的是相对于执行python的时候的路径，比如说/root/1/2/3/test.py里面的代码是<code>os.path.dirname(__file__)</code>， 那么根据执行这个test.py的路径情况，会返回不同的结果，<br>如果是通过<code>python /root/1/2/3/test.py</code>方式执行， 那么返回/root/1/2/3，如果是在3目录下执行<code>python test.py</code>返回的是空，如果是在root/1目录下执行，返回2/3，如果需要获取全路径，使用<code>os.path.abspath(__file__)</code></p></blockquote><h3 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h3><p>里面有一个类Popen 其中第一个参数是需要执行的命令，还有stdout=subprocess.PIPE, stderr=subprocess.PIPE，他们的默认值是None，如果不配置为PIPE，是无法通过popen对象<br>的communicate获取输出的，如果是None，默认输出到屏幕，如果设置为PIPE，可以通过communicate函数获取输出，communicate也接收一个参数作为输入，此时需要制定stdin也等于PIPE<br>，communicate返回一个二元组，第一个是stdout，第二个是stderr，有可能为空，poll是检查子进程是否结束，结束返回指定的命令返回代码，否则返回None，wait同理，但是会一直等，poll<br>不会，kill可以杀死进程。</p><h3 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(&apos;utf8&apos;)</span><br></pre></td></tr></table></figure><h3 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h3><p>如果要下发ctrl+c，代码是<code>\x03</code>，引申ctrl+a，是<code>\x01</code></p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>random是产生随机数的库。</p><p>产生一个int的随机数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.randint(-100， 100) #会产生一个-100到100之间的随机数，包括-100和100</span><br></pre></td></tr></table></figure></p><p>从一个序列中随机选择一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.choice(range(100)) #从0-99中随机选择一个</span><br><span class="line">random.choice(&apos;abcde&apos;) #从abcde中随机选择一个</span><br></pre></td></tr></table></figure></p><p>从一个序列中随机选择出一个新的序列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">random.sample(range(100), 5) #从0-99中选择5个数组成一个新的序列</span><br></pre></td></tr></table></figure></p><p>注意<code>sample</code>的第二个参数不能大于第一个序列的长度，<code>sample</code>不会重复选择同一个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.random() #会产生一个0.0 &lt;= a &lt; 1.0之间的浮点数</span><br><span class="line">random.uniform(1, 5) #会产生一个1到5之间的浮点数</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 专项 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[专项]-robotframework</title>
      <link href="/2128/06/28/special-robotframework/"/>
      <url>/2128/06/28/special-robotframework/</url>
      <content type="html"><![CDATA[<p>本文主要记录了robotframework框架的一些使用笔记。</p><p>本文实际发布时间是2018-06-25，为了置顶，所以修改了发布时间为将来的某个时间。</p><a id="more"></a><h2 id="常用命令参数"><a href="#常用命令参数" class="headerlink" title="常用命令参数"></a>常用命令参数</h2><p>默认的使用方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pybot casefile.txt</span><br></pre></td></tr></table></figure><p>其中最后一个参数就是需要运行用例或者用例目录，其它参数都必须位于这个参数前面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定输出路径</span><br><span class="line">pybot -d test case.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定运行lib</span><br><span class="line">pybot -P test case.txt</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 指定运行tag</span><br><span class="line">-i tagname</span><br><span class="line"># 排除包含tag的case</span><br><span class="line">-e tagname</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定运行级别</span><br><span class="line">-L trace</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定变量值</span><br><span class="line">-v var:value</span><br></pre></td></tr></table></figure><h2 id="日志修复"><a href="#日志修复" class="headerlink" title="日志修复"></a>日志修复</h2><p>有时候使用robot跑了脚本，如果想中间停止，或者中间抛出了错误，只产生了一个output.xml文件，这个文件不便于阅读，想转换为好看的log.html，可以使用下面的方法进行日志修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install robotfixml</span><br><span class="line">python -m robotfixml output.xml fixed.xml</span><br><span class="line">rebot fixed.xml</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 专项 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[专项]-英语</title>
      <link href="/2128/06/27/special-english/"/>
      <url>/2128/06/27/special-english/</url>
      <content type="html"><![CDATA[<p>主要记录了学习英语的笔记。</p><p>本文实际发布时间是2018-06-25，为了置顶，所以修改了发布时间为将来的某个时间。</p><a id="more"></a><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="疑问句"><a href="#疑问句" class="headerlink" title="疑问句"></a>疑问句</h3><p>疑问句主要分为 一般疑问句 特殊疑问句 选择疑问句</p><h4 id="一般疑问句"><a href="#一般疑问句" class="headerlink" title="一般疑问句"></a>一般疑问句</h4><p>一般疑问句使用yes/no来回答，她包含两个家族(含有be动词或者情态动词的家族， 助动词家族)：</p><h5 id="含有be动词或者情态动词的家族"><a href="#含有be动词或者情态动词的家族" class="headerlink" title="含有be动词或者情态动词的家族"></a>含有be动词或者情态动词的家族</h5><p>Be + 主语 + 其它部分？<br>情态动词 + 主语 + 动词原形 + 其它部分？</p><p>回答可以使用：</p><p>肯定： Yes, 主语 + be/情态动词.<br>否定： No, 主语 + be/情态动词 not.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Is this your English book?</span><br><span class="line">Yes, it is./No, it isn&apos;t.</span><br><span class="line">Can you speack English?</span><br><span class="line">Yes, I can./No, I can&apos;t.</span><br></pre></td></tr></table></figure><h5 id="助动词家族"><a href="#助动词家族" class="headerlink" title="助动词家族"></a>助动词家族</h5><p>助动词 + 主语 + 动词原型 + 其它部分？</p><p>回答可以使用：</p><p>肯定： Yes, 主语 + do/does.<br>否定： No, 主语 + do/does not.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Do you like English?</span><br><span class="line">Yes, I do./No, I don&apos;t.</span><br></pre></td></tr></table></figure><h4 id="特殊疑问句"><a href="#特殊疑问句" class="headerlink" title="特殊疑问句"></a>特殊疑问句</h4><p>是以特殊疑问词开头，对句中某一成分提问，常用的特殊疑问词有 what, who, whose, which, when, where, why, how等。</p><p>有两种语序(对主语提问，对其它部分提问)。</p><h5 id="对主语提问"><a href="#对主语提问" class="headerlink" title="对主语提问"></a>对主语提问</h5><p>对主语提问，这时候要使用陈述语序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Who is singing in the room?</span><br><span class="line">Whose bike is broken?</span><br></pre></td></tr></table></figure><h5 id="对其它部分提问"><a href="#对其它部分提问" class="headerlink" title="对其它部分提问"></a>对其它部分提问</h5><p>对其它部分提问，这时候要使用特殊疑问词+一般疑问句的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">What does she like?</span><br><span class="line">What class are you in?</span><br></pre></td></tr></table></figure><h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><p>动作发生的时间，以及动作的状态， 时间上有 过去，现在，将来， 状态上有 一般 完成 进行 完成进行</p><p>一般现在：do<br>一般过去：did<br>一般将来：will do<br>一般过去将来：would do</p><p>现在进行：is doing<br>过去进行：was doing<br>将来进行：will be doing<br>过去将来进行：would be doing</p><p>现在完成：has done<br>过去完成：had done<br>将来完成：will have done<br>过去将来完成：would have done</p><p>现在完成进行：has been doing<br>过去完成进行：had been doing<br>将来完成进行：will have been doing<br>过去将来完成进行：would have been doing</p><h3 id="被动语法"><a href="#被动语法" class="headerlink" title="被动语法"></a>被动语法</h3><p>注意被动与时态的区别，现在进行时是 is been doing (首先判断is表示是现在， doing判断是进行， been判断是被动)</p><h3 id="句型成分分析"><a href="#句型成分分析" class="headerlink" title="句型成分分析"></a>句型成分分析</h3><h4 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h4><p>名词和形容词都可以作表语，并且系动词替换为be动词之后，语义几乎不变。</p><h4 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h4><p>名词和形容词都可以作补语，补语是对宾语的补充，不能缺少，并且与宾语通过be动词和补语一起能组成独立的句子，语义几乎不变。</p><p>补语是名词从句的省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I found that the homework was difficult.</span><br><span class="line">I found the homework difficult.</span><br></pre></td></tr></table></figure><p>句子1是名词从句，其中形容词difficult作为表语，句子2中的difficult是省略后的。</p><h4 id="五大简单句型"><a href="#五大简单句型" class="headerlink" title="五大简单句型"></a>五大简单句型</h4><p>S 代表主语， V 代表谓语， O 代表宾语， P 代表表语， C 代表补语</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">S V</span><br><span class="line">S V O</span><br><span class="line">S V O O</span><br><span class="line">S V O C</span><br><span class="line">S V P</span><br></pre></td></tr></table></figure><p>S V O O 中第一个O是间接宾语，第二个O是直接宾语</p><h5 id="SVO-SVP的区分"><a href="#SVO-SVP的区分" class="headerlink" title="SVO SVP的区分"></a>SVO SVP的区分</h5><p>O位置只能是名词， P位置可以是名词和形容词<br>通过把V替换为be动词之后，语义几乎不变的是SVP</p><h5 id="SVOO-SVOC的区分"><a href="#SVOO-SVOC的区分" class="headerlink" title="SVOO SVOC的区分"></a>SVOO SVOC的区分</h5><p>O位置只能是名词，C位置可以是名词和形容词<br>去掉SV，在O后面加上be动词和后面的成分组成独立的句子，并且意思几乎不变的就是SVOC</p><h3 id="词性"><a href="#词性" class="headerlink" title="词性"></a>词性</h3><p>总共有4大词性，名词，动词，形容词，副词</p><p>又有七大类结构可以充当这几种词性</p><p><img src="/2128/06/27/special-english/cixing.png" alt="cixing"></p><p><img src="/2128/06/27/special-english/seven.png" alt="seven"></p><h4 id="副词的用法"><a href="#副词的用法" class="headerlink" title="副词的用法"></a>副词的用法</h4><p>副词是用于修饰除了名词和代词以外的结构。</p><p>副词可以修饰副词，形容词，动词以及可以充当这三类结构的组合。</p><p>副词可以分为三类用法。</p><h5 id="disjunct-分离"><a href="#disjunct-分离" class="headerlink" title="disjunct(分离)"></a>disjunct(分离)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Clearly, We have got the tropy(奖杯). Clearly作为副词，与句子单独分离</span><br></pre></td></tr></table></figure><h5 id="adjunct-附加"><a href="#adjunct-附加" class="headerlink" title="adjunct(附加)"></a>adjunct(附加)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">She knows me well. well作为副词修饰know，在句子内部</span><br></pre></td></tr></table></figure><h5 id="conjunct-连接"><a href="#conjunct-连接" class="headerlink" title="conjunct(连接)"></a>conjunct(连接)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I&apos;d like to help you. However, my hands are full. However作为副词，用于连接两个句子</span><br></pre></td></tr></table></figure><h5 id="副词的位置"><a href="#副词的位置" class="headerlink" title="副词的位置"></a>副词的位置</h5><p>副词修饰一般位于被修饰的结构前面，并且位置紧邻，但是修饰动词的时候，可以放在动词的后面，并且位置可以不紧邻。</p><h5 id="副词类结构"><a href="#副词类结构" class="headerlink" title="副词类结构"></a>副词类结构</h5><p>我们知道，介词短语，状语从句，分词，不定式这四类结构都可以充当副词词性。</p><p>上面说的三类用法，disjunct, adjunct, conjunct, 其中只有介词短语可以作为conjunct使用，除了状语从句外，都可以作为adjunct使用，四类结构都可以作为disjunct使用。</p><h5 id="垂悬修饰"><a href="#垂悬修饰" class="headerlink" title="垂悬修饰"></a>垂悬修饰</h5><p>先看一个概念，逻辑主语，看下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hearing their tearcher&apos;s voice, the pupils stopped talking at once.</span><br></pre></td></tr></table></figure><p>在Hearing their tearcher’s voice中hear是谓语，their tearcher’s voice是宾语，唯一缺少的就是主语，其实这里是被省略掉了，因为后面的句子the pupils stopped talking at once中的主语<br>the pupils和前面的主语是一致的，所以被省略了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The pupils was hearing their tearch&apos;s voice, the pupils stopped talking at once.</span><br></pre></td></tr></table></figure><p>非谓语动词(分词，动名词，不定式)都存在逻辑主语的概念。</p><p>英语中，如果逻辑主语和主句的主语不同，这就是垂悬修饰，这是不能在英语里面出现的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opening the window, stars were calling my name.(打开窗户，星星在召唤我)</span><br></pre></td></tr></table></figure><p>上面的句子看似没有错误，其实是错的，因为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stars were opening the windows, stars were calling my name. 分词的逻辑主语显然不对</span><br></pre></td></tr></table></figure><p>其实修改为下面的情况，句子就对了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opening the window, I heard stars calling my name.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I was opening the window, I heard stars calling my name.</span><br></pre></td></tr></table></figure><h4 id="形容词的用法"><a href="#形容词的用法" class="headerlink" title="形容词的用法"></a>形容词的用法</h4><p>可以修饰名词，代词(但是只能修饰不定代词，因为普通代词，比如He，这个代词已经很明确的指明了是谁，不应该在加入修饰去限定了)</p><p>在修饰名词的时候，一般位于被修饰词的前面，但是在修饰复合代词的时候，一般位于被修饰的词后面。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Do you know anybody interesting?</span><br></pre></td></tr></table></figure><p>这里的interesting是形容词，修饰anybody，如果换成<code>Do you know intereting anybody?</code>这样会显得很别扭。</p><p>另外，七大类辅助结构中，介词短语，定语从句，分词，不定式都可以作为形容词使用，但是和副词不一样，它们只能放在被修饰的词后面，这里和中文的顺序不一致了，因为中文里面有一个万能的<br>词叫<code>的</code>，中文因为有了它，顺序就和英语中不一样了。</p><h4 id="名词的用法"><a href="#名词的用法" class="headerlink" title="名词的用法"></a>名词的用法</h4><p>名词可以充当 主 表 宾 补几类。 其中七大类辅助结构中，只有名词性从句，动名词，不定式可以作为名词使用。</p><h3 id="从句分析"><a href="#从句分析" class="headerlink" title="从句分析"></a>从句分析</h3><p>复杂句里面分为并列句和从句，并列句就是前后两个句子重要性一样，没有谁修饰谁，有这么一类连接词<code>FANBOYS</code>是属于这一类的，for and nor but or yes so。</p><p>从句和特殊疑问句类似，都是特殊疑问词开始，后面是内容，但是从句里面，无论什么情况，都不会有助动词提前的情况，特殊疑问句里面，对除了主语提问的结构，都会有助动词提前的情况，<br>从句里面不会提前，并且特殊疑问句是可以单独成句的，而从句单独独立出来不能成为一个完整的句子。</p><h4 id="名词从句"><a href="#名词从句" class="headerlink" title="名词从句"></a>名词从句</h4><h4 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h4><h4 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h4><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><h3 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h3><p>This reference manual describes the syntax and “core semantics” of the language. It is terse, but attempts to be exact and completes. The semantics of non-essential built-in object types and of the<br>built-in functions and modules are described in the Python Standard Library. For an informal introduction to the language, see the Python Tutorial. For C or C++ programmers, two additional manuals exist:<br>Extending and Embedding the Python Interpreter describes the high-level picture of how to write a Python extension mudule, and the Python/C API Reference Manual describes the interface available to C/C++<br>programmers in detail.</p><p>单词：<br>reference manual: 参考手册<br>core semantics<code>(/sə&#39;mæntɪks/)</code>：核心语义<br>terse：简洁的，精炼的<br>exact：adj 准确的<br>informal：非正式的，通俗的<br>Extending and Embedding<code>(/im&#39;bediŋ/)</code>：扩展和植入</p><p>成分分析：<br>This reference manual describes the syntax and “core semantics” of the language.<br>主语：This reference manual<br>谓语：describes<br>宾语：the syntax and “core semantics”<br>其它成分：of the language 是介词短语，作形容词词性作为宾补</p><p>The semantics of non-essential built-in object types and of the built-in functions and modules are described in the Python Standard Library.<br>主语：The semantics + modules<br>谓语：described<br>表语：in the Python Standard Library(介词短语)<br>其它成分：<br>of non-essential built-in object types and of the built-in functions 介词短语，作为形容词词性修饰主语The semantics<br>are 表示是一般现在时，described表示被动语态</p>]]></content>
      
      <categories>
          
          <category> 专项 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[专项]-工具合计</title>
      <link href="/2128/06/25/special-tools/"/>
      <url>/2128/06/25/special-tools/</url>
      <content type="html"><![CDATA[<p>本文主要记录了一些工具的使用，主要包括：Windows、 Linux、 Jenkins、Gitblit等。</p><p>本文实际发布时间是2018-06-25，为了置顶，所以修改了发布时间为将来的某个时间。</p><a id="more"></a><h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><h4 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h4><p><code>shutdown -r</code> 是重启系统， <code>shutdown -s</code> 是关机。</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>这个配置在 控制面板-小图标-管理工具-任务计划程序 这里就可以进行配置。</p><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>找到<code>InstallUtil.exe</code>这个文件，然后在命令行使用<code>InstallUtil.exe servicename</code>安装你的服务，可以通过<code>InstallUtil.exe /u servicename</code>卸载服务，然后就可以使用<code>net start/stop servicename</code>对服务进行启动/停止了。</p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="命令行-1"><a href="#命令行-1" class="headerlink" title="命令行"></a>命令行</h3><h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><ol><li>查看内存信息: <code>cat /proc/meminfo</code></li><li>查看系统在线时长： uptime</li></ol><h4 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 somefile</span><br><span class="line">chown jenkins testdir <span class="comment">#修改所属用户</span></span><br><span class="line">chown -R jenkins testdir <span class="comment">#递归</span></span><br><span class="line">chgrp jenkins testdir <span class="comment">#修改所属用户组</span></span><br><span class="line">chgrp -R jenkins testdir <span class="comment">#递归</span></span><br></pre></td></tr></table></figure><h2 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h4><p>直接下载jenkins的jar包，放到任意目录下，在cmd命令行执行 <code>java -jar jenkins.war</code> 即可，然后通过 <a href="https://ip:8080/" target="_blank" rel="noopener">https://ip:8080/</a> 就可访问了，最开始会提示进行安装，安装提示即可简单的完成。</p><h3 id="常用url"><a href="#常用url" class="headerlink" title="常用url"></a>常用url</h3><ol><li>内建变量： <a href="http://10.10.11.240:8080/env-vars.html/" target="_blank" rel="noopener">http://10.10.11.240:8080/env-vars.html/</a></li><li>重启： <a href="http://localhost:8080/restart" target="_blank" rel="noopener">http://localhost:8080/restart</a></li><li>重新加载： <a href="http://localhost:8080/reload" target="_blank" rel="noopener">http://localhost:8080/reload</a></li></ol><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><h4 id="定时执行"><a href="#定时执行" class="headerlink" title="定时执行"></a>定时执行</h4><p><code>H 21 * * *</code> 这个意思是每天晚上9点执行</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="Job顺序"><a href="#Job顺序" class="headerlink" title="Job顺序"></a>Job顺序</h4><p>有这么一个需求： 有个名为X的job，需要等待A, B, C, D等几个job都完成后再执行， 默认的jenkins的job flow都是只要A, B, C, D中任何一个完成了， 就会触发X这个job， 不满足条件，但是有个join plugin这个插件可以完成这个功能， 但是需要附加一个job，比如名为Z，<br>则需要在Z这个job里面配置构建后步骤，需要增加两个步骤， 一是 Build other projects， 里面填入 A, B, C, D几个job， 二是增加 Join Trigger(这个需要安装了join plugin这个插件后才会有的选项)， 在Projects to build once, after all downstream projects have finished这个里面<br>填入X这个job。那么运行Zjob完成后，会触发A, B, C, D的运行，并且X这个job会等待A, B, C, D都完成后再执行。</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="Opening-Robot-Framework-log-failed"><a href="#Opening-Robot-Framework-log-failed" class="headerlink" title="Opening Robot Framework log failed"></a>Opening Robot Framework log failed</h4><p>Opening Robot Framework log failed<br>Verify that you have JavaScript enabled in your browser.<br>Make sure you are using a modern enough browser. Firefox 3.5, IE 8, or equivalent is required, newer browsers are recommended.<br>Check are there messages in your browser’s JavaScript error log. Please report the problem if you suspect you have encountered a bug.</p><p>如果遇见上面的错误，可以在 系统管理-脚本命令行 里面输入 <code>System.setProperty(&quot;hudson.model.DirectoryBrowserSupport.CSP&quot;,&quot;&quot;)</code>执行后，重新打开浏览器即可。</p><h2 id="Gitblit"><a href="#Gitblit" class="headerlink" title="Gitblit"></a>Gitblit</h2><p>Gitblit是一个git服务器，它可以通过web界面进行管理。</p><h3 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h3><h4 id="Windows下安装-1"><a href="#Windows下安装-1" class="headerlink" title="Windows下安装"></a>Windows下安装</h4><p>直接下载好windows下的安装包后，解压，进入解压目录，使用gitblit.cmd直接运行即可。</p><p>可以通过 <a href="https://ip:8443/" target="_blank" rel="noopener">https://ip:8443/</a> 这个地址访问，默认的管理员用户名和密码都是admin。</p><blockquote><p>注意，由于gitblit是基于java开发的，所以需要java的运行环境，需要配置好java的环境变量， JAVA_HOME是jdk安装路径，Path环境变量里面需要增加%JAVA_HOME%\bin和%JAVA_HOME%\jre\bin</p></blockquote><h3 id="工单配置"><a href="#工单配置" class="headerlink" title="工单配置"></a>工单配置</h3><p>默认情况下，gitblit是没有打开工单功能的，需要在gitblit的data目录下的defaults.properties这个文件中，配置tickets.serveice，这个默认是空的，根据需要配置，注释里面提供了很多的选项，我只使用过com.gitblit.tickets.FileTicketService这个。</p><h2 id="其它工具"><a href="#其它工具" class="headerlink" title="其它工具"></a>其它工具</h2><h3 id="excel"><a href="#excel" class="headerlink" title="excel"></a>excel</h3><h4 id="筛选功能"><a href="#筛选功能" class="headerlink" title="筛选功能"></a>筛选功能</h4><p>有时候筛选结果没有内容，是因为所筛选的列下面有空的单元格，可以使用ctrl+f替换为空格即可。</p><h3 id="notpad"><a href="#notpad" class="headerlink" title="notpad++"></a>notpad++</h3><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>注释: ctrl + q</p>]]></content>
      
      <categories>
          
          <category> 专项 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-markdown</title>
      <link href="/2018/06/14/tool-markdown/"/>
      <url>/2018/06/14/tool-markdown/</url>
      <content type="html"><![CDATA[<p>主要记录了markdown的基本用法。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Markdown 的目标就是 易读易写，她的语法有一些text-to-HTML格式，Markdown的语法由一些精挑细选的符号组成，Markdown不是想要取代HTML，因为HTML已经很简单了，她们的区别就是，HTML是一种发布格式，Markdown是一种书写格式，Markdown兼容HTML，如果需要的格式不在Markdown范围内，你可以使用HTML来代替，直接写在你的Markdown文档里面即可。</p><h2 id="工具安装"><a href="#工具安装" class="headerlink" title="工具安装"></a>工具安装</h2><p>如果要编写markdown，最好是有一款能马上看见成果的工具，推荐配合python和jupyter使用。</p><p>首先你需要安装python。</p><p>然后通过pip安装jupyter</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><p>然后通过命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure><p>就可以打开浏览器看见我们的jupyter启动啦，里面不仅仅可以调试python，还可以编写markdown，还可以两者一起使用，配合插件，还可以把编写的文档转换为html，rts，pdf等各种文件格式</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>使用<code>#</code>来表示标题，根据<code>#</code>的数量的多少来决定标题的分阶。<code>#</code>后面空一格，后面的内容就是标题内容</p><p>比如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 这是H1</span></span><br><span class="line"><span class="section">## 这是H2</span></span><br></pre></td></tr></table></figure><p>当然你也可以在最后加上<code>#</code>，这不是强制要求，而且最后的数量也不限制，只有开始的<code>#</code>会限制标题的阶数</p><h3 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h3><p>效果如下：</p><blockquote><p>这是区块1</p></blockquote><blockquote><blockquote><p>这是子区块</p></blockquote></blockquote><p>他们源码是：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 这是区块1</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; 这是区块2</span><br></pre></td></tr></table></figure><p>注意其中的空行，空行在markdown里面是很重要的一个区分的概念。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>效果如下：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>源码是:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>Red</span><br><span class="line"><span class="bullet">* </span>Green</span><br><span class="line"><span class="bullet">* </span>Blue</span><br></pre></td></tr></table></figure><p>当然上面的<code>*</code>也可替换成<code>+</code> 或 <code>-</code> 都是一样的效果</p><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>效果如下：</p><ol><li>Bird</li><li>Mchale</li><li>Parish</li></ol><p>源码：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>Bird</span><br><span class="line"><span class="bullet">1. </span>Mchale</span><br><span class="line"><span class="bullet">2. </span>Parish</span><br></pre></td></tr></table></figure><p>很奇怪？ 明明是1 1 2，对的，markdown会自动给你的有序列表安排序号，不管你怎么写。</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>如果想在一个段落里单独加入一些代码块，比如<code>printf()</code>，可以使用 `printf()`，这里的符号是键盘上TAB键上面那个。</p><p>效果2，下面是一整块的代码块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testpython</span><span class="params">(para)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> para:</span><br><span class="line">        <span class="keyword">print</span> para</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>只需要在代码段的前后分别加入三个`即可</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>在一行中使用三个以上的星号，减号，底线来建立一个分割线，行内不能有其它东西，比如：</p><hr><p>上面有一个分割线</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>效果：</p><p>This is <em>em</em> and this is <strong>strong</strong>.</p><p>源码是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is *em* and this is **strong**.</span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>比如，本文的参考链接是: <a href="https://www.appinn.com/markdown/" target="_blank" rel="noopener">markdown语法说明</a></p><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[markdown语法说明](https://www.appinn.com/markdown/)</span><br></pre></td></tr></table></figure><p>另外一种格式: <a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度][someid]</span><br></pre></td></tr></table></figure><p>在文章的任意地方，当然最好是文章的底部加入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[someid]: http://www.baidu.com</span><br></pre></td></tr></table></figure><p>备注： 如果链接的是图片的话，直接在左边的方括号前面加上一个感叹号即可，然后圆括号里面放入图片的地址，可以是本地的，也可以是远程的。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-python3的使用</title>
      <link href="/2018/06/07/py-py3/"/>
      <url>/2018/06/07/py-py3/</url>
      <content type="html"><![CDATA[<p>由于以后python2不在维护，所以准备基于python3开发新的自动化测试框架，以后python2的自动化测试会转移到python3上。</p><p>本文记录了一些使用python3的一些知识。</p><a id="more"></a><h2 id="python2-与-python3-共用"><a href="#python2-与-python3-共用" class="headerlink" title="python2 与 python3 共用"></a>python2 与 python3 共用</h2><p>由于在同一台pc上都装了python2和python3，那么这里专门对python3配置了虚拟环境。</p><p>具体使用参见: <a href="https://liburro.github.io/2018/04/27/py-virtualenv/" target="_blank" rel="noopener">https://liburro.github.io/2018/04/27/py-virtualenv/</a></p><h2 id="python3与python2的不同"><a href="#python3与python2的不同" class="headerlink" title="python3与python2的不同"></a>python3与python2的不同</h2><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>首先<code>print</code>在python3中变成了函数，使用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;something&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [3]: <span class="built_in">print</span>?</span><br><span class="line">Docstring:</span><br><span class="line"><span class="built_in">print</span>(value, ..., sep=<span class="string">' '</span>, end=<span class="string">'\n'</span>, file=sys.stdout, flush=False)</span><br><span class="line"></span><br><span class="line">Prints the values to a stream, or to sys.stdout by default.</span><br><span class="line">Optional keyword arguments:</span><br><span class="line">file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">sep:   string inserted between values, default a space.</span><br><span class="line">end:   string appended after the last value, default a newline.</span><br><span class="line">flush: whether to forcibly flush the stream.</span><br><span class="line">Type:      builtin_function_or_method</span><br></pre></td></tr></table></figure><h3 id="Views-和-Iterators-代替-列表"><a href="#Views-和-Iterators-代替-列表" class="headerlink" title="Views 和 Iterators 代替 列表"></a>Views 和 Iterators 代替 列表</h3><ol><li>字典对象的几个函数，dict.keys() dict.items() dict.values()现在都返回视图对象，比如不支持下面的操作了，k = d.keys(); k.sort(),但是你可以使用k = sorted(d)来完成</li><li>那么，dict.iterkeys(), dict.iteritems()　dict.itervalues()已经不支持了。</li><li>map() 和 filter() 现在返回的是iterator对象，如果你确实想要返回的是一个list对象，那么使用list()函数进行一个包装，比如list(map(…))即可。</li><li>range()函数现在已经类似xrange()。</li><li>zip()函数现在返回的也是iterator对象。</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol><li>如果比较的对象不是同类型的或者根本无法进行自然比较的，会抛出TypeError异常，比如 1 &lt; ‘’, 0 &gt; None, None &lt; None, len &lt; len等(这里的len是内置函数len)</li><li>builtin.sorted 和 list.sort 都不支持cmp这个参数了，因为key这个参数完全可以完成相同的功能</li><li>cmp函数应该确保不在使用，同时<code>__cmp__</code>特殊函数也不在支持，你可以使用<code>(a &gt; b) - (a &lt; b)</code>来代替<code>cmp(a, b)</code>，当然<code>__lt__, __eq__</code>等函数仍然支持</li></ol><p>下图中，左边是py2，右边是py3<br><img src="/2018/06/07/py-py3/cmp.png" alt="cmp"></p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ol><li>本质上讲，已经没有long这种类型，都是int类型，但是int类型很多特性和long类型一致</li><li>1 / 2返回的是float， 1//2返回除数，看下图<br><img src="/2018/06/07/py-py3/div.png" alt="div"></li><li>sys.maxint已经被移除，因为不在限制int的值，但是sys.maxsize可以用</li><li>8进制不支持<code>0720</code>格式，需要使用<code>0o720</code>来代替。</li></ol>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-jupyter使用</title>
      <link href="/2018/06/06/tool-jupyter/"/>
      <url>/2018/06/06/tool-jupyter/</url>
      <content type="html"><![CDATA[<p>jupyter工具使用手册，本质是一个web的应用程序，可以编辑和运行<code>python</code>代码，而且方便编辑<code>markdown</code>。</p><p>本文主要以python3.6.5为例进行</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="http://jupyter.org/install.html" target="_blank" rel="noopener">http://jupyter.org/install.html</a></p><p>直接通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jupyter</span><br></pre></td></tr></table></figure><p>安装即可</p><p>然后使用下面的命令启动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[英语单词]-单词记忆</title>
      <link href="/2018/06/06/en-word/"/>
      <url>/2018/06/06/en-word/</url>
      <content type="html"><![CDATA[<p>单词本</p><a id="more"></a><h2 id="记忆单词"><a href="#记忆单词" class="headerlink" title="记忆单词"></a>记忆单词</h2><p>maintenance n 维护 维修 保持 生活费用</p><p>enhancement n 增加 放大</p><h2 id="记忆句子"><a href="#记忆句子" class="headerlink" title="记忆句子"></a>记忆句子</h2><p>Python is an easy to learn(learn是动词, to learn是不定式，作为adv词性修饰adj easy简单的), powerful(adj 强大的，修饰programming language) programming(现在分词具有adj性质，修饰n language) language. (主干是Python is a language.)</p><p>Python is an esay to learn, powerful programming language. It has efficient(adj, 有效率的，有能力的) high-level(高级的，高阶的) data structures and a simple(adj 简单的，单纯的，天真的) but effective(adj, 有效的，起作用的，实际的) approach(n 方法，途径; vt 接近，着手处理; vi 靠近) to object-oriented programming. Python’s elegant(adj 高雅的，优雅的，简练的，简洁的) syntax and dynamic(adj 动态的 n 动态， 动力) typing, together with its interpreted nature(解释语言的特性), make it an ideal(adj 理想的，完美的; n 理想 典范) laguage for scripting and rapid(adj 迅速的，飞快的) application development(n 发展，开发，发育) in many areas on most platforms.</p><h2 id="计算机相关单词"><a href="#计算机相关单词" class="headerlink" title="计算机相关单词"></a>计算机相关单词</h2><h3 id="bug-相关单词"><a href="#bug-相关单词" class="headerlink" title="bug 相关单词"></a>bug 相关单词</h3><p>severity(严重级别): unrated(未分级) negligible(微不足道的) minor(中等的) serious(严重的) critical(危险的) catastrophic(灾难的)</p><p>priority(优先级): urgent(立即) high normal low</p><h3 id="编程相关"><a href="#编程相关" class="headerlink" title="编程相关"></a>编程相关</h3><p>argument 表示函数的参数</p><p>parameter 表示调用函数的时候传递的参数</p><p>keyword arguments 表示关键字参数，就是有默认值的参数</p>]]></content>
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-tcpdump使用</title>
      <link href="/2018/06/05/tool-tcpdump/"/>
      <url>/2018/06/05/tool-tcpdump/</url>
      <content type="html"><![CDATA[<p>tcpdump抓包工具使用手册</p><a id="more"></a><h2 id="根据指定IP地址"><a href="#根据指定IP地址" class="headerlink" title="根据指定IP地址"></a>根据指定IP地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 host 192.168.150.1</span><br></pre></td></tr></table></figure><h2 id="根据指定的协议"><a href="#根据指定的协议" class="headerlink" title="根据指定的协议"></a>根据指定的协议</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 udp</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 icmp</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-lib-os模块</title>
      <link href="/2018/06/05/py-lib-os/"/>
      <url>/2018/06/05/py-lib-os/</url>
      <content type="html"><![CDATA[<p>python os模块手册</p><a id="more"></a><h2 id="os-sep"><a href="#os-sep" class="headerlink" title="os.sep"></a>os.sep</h2><p>当前操作系统路径分隔符，比如windows下是<code>\\</code>，linux下是<code>/</code></p><h2 id="os-linesep"><a href="#os-linesep" class="headerlink" title="os.linesep"></a>os.linesep</h2><p>当前操作系统换行符，有<code>\r\n</code> <code>\r</code> <code>\n</code> <code>\n\r</code>等</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-git的使用</title>
      <link href="/2018/06/05/tool-git/"/>
      <url>/2018/06/05/tool-git/</url>
      <content type="html"><![CDATA[<p>git使用手册</p><a id="more"></a><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="多重库"><a href="#多重库" class="headerlink" title="多重库"></a>多重库</h3><p>如果一个库里面包含另外一个库，比如A库里面有一个子库B，可以在A库的.ignore里面增加子库B，那么A库和B库就可以单独分离</p><h3 id="新建服务器分支"><a href="#新建服务器分支" class="headerlink" title="新建服务器分支"></a>新建服务器分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin new_branch</span><br></pre></td></tr></table></figure><p>直接上传新的分支即可</p><h3 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h3><p>在需要合并的分支上执行下面的命令即可，比如master分支，当在分支dev中开发完成后，需要合并到master分支上，先切换到master分支，然后进行合并即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge new_branch</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>返回add之前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><p>还有hard mixed几种方式</p><h3 id="修改提交的log"><a href="#修改提交的log" class="headerlink" title="修改提交的log"></a>修改提交的log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add --all <span class="comment">#add所有修改</span></span><br><span class="line">git add .    <span class="comment">#类似--all</span></span><br><span class="line">git add spc_file <span class="comment">#add特定的文件spc_file</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"msg"</span> <span class="comment">#提交add之后的修改到repo，并且增加消息msg</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push <span class="comment">#直接上传</span></span><br><span class="line">git push origin master <span class="comment">#上传到master分支</span></span><br><span class="line">git push origin dev <span class="comment">#上传到dev分支</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-gitblit的使用</title>
      <link href="/2018/06/05/tool-gitblit/"/>
      <url>/2018/06/05/tool-gitblit/</url>
      <content type="html"><![CDATA[<p>gitblit工具手册，gitblit是一个可以在windows端搭建git服务器的工具，提供web浏览界面。</p><p>本文是在win7 64环境下进行操作。</p><a id="more"></a><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>由于gitblit是使用java开发的，所以需要安装java环境。</p><p><img src="/2018/06/05/tool-gitblit/java_env1.png" alt="java-env"><br><img src="/2018/06/05/tool-gitblit/java_env2.png" alt="java-env"></p><p>去gitblit上下载好后，直接解压出来即可。</p><p>然后找到解压目录下的<code>gitblit.cmd</code>文件，直接运行，服务就启动了，可以通过：</p><p><code>https://192.168.53.133:8443/</code>就可以访问网页了，注意IP地址需要改成自己的。</p><p>默认的登陆用户名和密码分别是 admin admin</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="工单配置"><a href="#工单配置" class="headerlink" title="工单配置"></a>工单配置</h3><p>gitblit默认关闭了工单的，如果需要打开，需要配置data目录下的defaults.properties这个文件，配置属性tickets.service，其中这个默认是空的，根据注释可以看见提供了3中选择。</p><p><img src="/2018/06/05/tool-gitblit/tickets.png" alt="tickets"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[windows]-outlook相关配置</title>
      <link href="/2018/05/21/windows-outlook/"/>
      <url>/2018/05/21/windows-outlook/</url>
      <content type="html"><![CDATA[<p>本文主要记录了outlook的相关配置信息。</p><a id="more"></a><h2 id="密码记住功能"><a href="#密码记住功能" class="headerlink" title="密码记住功能"></a>密码记住功能</h2><p>有时候更改了密码，outlook在每次登陆的时候都要输入密码，就算点击了记住凭证也无效，每次打开outlook后都会弹出输入密码的提示框，可以按照下面的方式进行处理。</p><p><img src="/2018/05/21/windows-outlook/windows-outlook-password.gif" alt="password"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-jenkins的基本使用</title>
      <link href="/2018/05/15/tool-jenkins/"/>
      <url>/2018/05/15/tool-jenkins/</url>
      <content type="html"><![CDATA[<p>本文记录了jenkins的基本使用。</p><a id="more"></a><h2 id="任务触发器"><a href="#任务触发器" class="headerlink" title="任务触发器"></a>任务触发器</h2><h3 id="当前任务完成后触发其它任务"><a href="#当前任务完成后触发其它任务" class="headerlink" title="当前任务完成后触发其它任务"></a>当前任务完成后触发其它任务</h3><p><img src="/2018/05/15/tool-jenkins/post-build.png" alt="post"></p><h3 id="其它任务完成后触发当前任务"><a href="#其它任务完成后触发当前任务" class="headerlink" title="其它任务完成后触发当前任务"></a>其它任务完成后触发当前任务</h3><p><img src="/2018/05/15/tool-jenkins/pre-build.png" alt="pre"></p><h3 id="定时触发"><a href="#定时触发" class="headerlink" title="定时触发"></a>定时触发</h3><p><img src="/2018/05/15/tool-jenkins/build-prediodically.png" alt="time"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-wireshark</title>
      <link href="/2018/05/11/tool-wireshark/"/>
      <url>/2018/05/11/tool-wireshark/</url>
      <content type="html"><![CDATA[<p>本文主要记录了wireshark工具的使用。</p><a id="more"></a><h2 id="查看报文的data数据"><a href="#查看报文的data数据" class="headerlink" title="查看报文的data数据"></a>查看报文的data数据</h2><p>data部分的数据，wireshark里面看见的只是一堆16进制的数字，通过下面的方法，查看解析后的数据。</p><p><img src="/2018/05/11/tool-wireshark/view-data.gif" alt="view-data"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-xampp的使用</title>
      <link href="/2018/05/10/tool-xampp/"/>
      <url>/2018/05/10/tool-xampp/</url>
      <content type="html"><![CDATA[<p>本文主要记录了xampp的使用。</p><a id="more"></a><h2 id="远程访问数据库"><a href="#远程访问数据库" class="headerlink" title="远程访问数据库"></a>远程访问数据库</h2><p>默认情况是使用localhost/phpmyadmin只能在本机访问的，如果想通过其它机器访问，需要修改下面两个配置。</p><p><img src="/2018/05/10/tool-xampp/mysql-xampp.gif" alt="mysql-xampp"></p><p><img src="/2018/05/10/tool-xampp/mysql-auth.gif" alt="mysql-auth"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-远程连接工具的使用</title>
      <link href="/2018/05/10/tool-remote/"/>
      <url>/2018/05/10/tool-remote/</url>
      <content type="html"><![CDATA[<p>本文主要记录了一些远程连接工具的使用，比如SSH Secure, xmanager, xshell, securecrt等工具。</p><a id="more"></a><h2 id="远程打开linux上的界面"><a href="#远程打开linux上的界面" class="headerlink" title="远程打开linux上的界面"></a>远程打开linux上的界面</h2><p>比如linux上的firefox，可以通过如下方式在本地进行浏览。</p><p><img src="/2018/05/10/tool-remote/open-linux-firefox.gif" alt="firefox"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[tool]-vsphere的使用</title>
      <link href="/2018/05/10/tool-vsphere/"/>
      <url>/2018/05/10/tool-vsphere/</url>
      <content type="html"><![CDATA[<p>本文主要记录了vSphere工具的使用。</p><a id="more"></a><h2 id="虚拟机上电启动"><a href="#虚拟机上电启动" class="headerlink" title="虚拟机上电启动"></a>虚拟机上电启动</h2><p>服务器在重新启动后，默认虚拟机是不会随着服务器自动启动，按照下面的配置，可以在服务器启动后，虚拟机也启动。</p><p><img src="/2018/05/10/tool-vsphere/virtual-startup.gif" alt="startup"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[mysql]-实例</title>
      <link href="/2018/05/09/db-mysql-demo/"/>
      <url>/2018/05/09/db-mysql-demo/</url>
      <content type="html"><![CDATA[<p>本文主要使用MySQL来进行SQL语句练习。首先会创建一个数据库<code>sqltest</code>，会涉及两张表，<code>tb_websites</code>和<code>tb_accesslog</code>，第一张表里面有<code>id name url country</code> 几个字段，分别表示ID 名称 URL地址 国家，第二张表里面有<code>id site_id accesscount date</code>几个字典，分别表示ID <code>tb_websites</code>的ID 日访问量 日期。</p><a id="more"></a><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>创建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> sqltest;</span><br></pre></td></tr></table></figure><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_websites (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="keyword">url</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  country <span class="built_in">VARCHAR</span>(<span class="number">5</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">innoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_accesslog (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">  site_id <span class="built_in">INT</span>,</span><br><span class="line">  accesscount <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  <span class="built_in">date</span> <span class="built_in">DATE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">innoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><p>表创建完成后，里面没有数据，我们通过INSERT插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tb_websites <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'百度'</span>, <span class="string">'http://www.baidu.com'</span>, <span class="string">'CN'</span>);</span><br></pre></td></tr></table></figure><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hip -uuser -ppassword</span><br></pre></td></tr></table></figure><h3 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use database_name;</span><br></pre></td></tr></table></figure><h3 id="显示表"><a href="#显示表" class="headerlink" title="显示表"></a>显示表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="快速复制数据库"><a href="#快速复制数据库" class="headerlink" title="快速复制数据库"></a>快速复制数据库</h3><p>首先需要创建一个新的数据库，用于存储。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `bk_sks_test` DEFAULT CHARACTER SET UTF8 COLLATE UTF8_GENERAL_CI;</span><br></pre></td></tr></table></figure><p>然后使用mysqldump命令配置mysql进行复制，下面使用远程复制，如果是本机复制，就没有-h参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump sks_test -h10.10.11.117 -uroot  --add-drop-table | mysql bk_sks_test -h10.10.11.117 -uroot</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[linux]-常用命令</title>
      <link href="/2018/05/07/linux-common-cmd/"/>
      <url>/2018/05/07/linux-common-cmd/</url>
      <content type="html"><![CDATA[<p>本文收录了个人常用的linux命令，很基础的一些命令就没有列举了。</p><a id="more"></a><h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><img src="/2018/05/07/linux-common-cmd/ls.png" alt="ls"></p><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>用于匹配查找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep ISM_Base_0490 output.xml <span class="comment">#在output.xml文件中查找ISM_Base_0490</span></span><br></pre></td></tr></table></figure><p>-n: 打印所在行<br>-v: 反向匹配<br>-i: 忽略大小写<br>-A n: 显示匹配的前n行<br>-B n: 显示匹配的后n行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -A 5 -B 5 teststr</span><br></pre></td></tr></table></figure><h2 id="dh-df"><a href="#dh-df" class="headerlink" title="dh/df"></a>dh/df</h2><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><h2 id="ntpdata"><a href="#ntpdata" class="headerlink" title="ntpdata"></a>ntpdata</h2><p>如果需要和某个ntpserver进行时间同步，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntpserver_ip</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[cassandra]-基本操作</title>
      <link href="/2018/05/04/db-cassandra/"/>
      <url>/2018/05/04/db-cassandra/</url>
      <content type="html"><![CDATA[<p>可视化工具可以使用DevCenter.</p><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[windows]-cmd</title>
      <link href="/2018/05/03/windows-cmd/"/>
      <url>/2018/05/03/windows-cmd/</url>
      <content type="html"><![CDATA[<h2 id="查看目录树"><a href="#查看目录树" class="headerlink" title="查看目录树"></a>查看目录树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree /f</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[爬虫]-scrapy</title>
      <link href="/2018/05/03/spider-scrapy/"/>
      <url>/2018/05/03/spider-scrapy/</url>
      <content type="html"><![CDATA[<p>本文主要记录了python的scrapy爬虫框架的使用。本文使用python2.7版本。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scrapy</span><br></pre></td></tr></table></figure><p>安装完成后，使用下面的命令创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scrapy startproject firstspider <span class="comment">#这里的firstspider是你的项目名</span></span><br></pre></td></tr></table></figure><p>生成的目录结构类似：</p><p><img src="/2018/05/03/spider-scrapy/spider-dir.png" alt="spider-dir"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://python.jobbole.com/86405/" target="_blank" rel="noopener">http://python.jobbole.com/86405/</a><br><a href="http://python.jobbole.com/89122/" target="_blank" rel="noopener">http://python.jobbole.com/89122/</a></p>]]></content>
      
      <categories>
          
          <category> spider </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-lib-telnet</title>
      <link href="/2018/05/03/py-lib-telnet/"/>
      <url>/2018/05/03/py-lib-telnet/</url>
      <content type="html"><![CDATA[<p>本文记录了python通过telnet链接设备的是使用。</p><a id="more"></a><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> telnetlib <span class="keyword">import</span> Telnet</span><br><span class="line"></span><br><span class="line">tel = Telnet(<span class="string">'your_ipaddr'</span>)</span><br><span class="line">tel.read_until(<span class="string">'expected str'</span>, timeout) <span class="comment">#这里返回读取到的回显</span></span><br><span class="line">tel.write(<span class="string">'something'</span> + self.cr)</span><br><span class="line">tel.expect([<span class="string">'es1'</span>, <span class="string">'es2'</span>, <span class="string">'\d+'</span>], timeout) <span class="comment">#这里第一个参数必须是列表，里面内容可以是正则表达式，返回3个元素的元组，最后一个是读取到的内容</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： expect返回一个三元组，第一个是匹配到expect第一个参数里面的索引，比如上例中如果匹配到了es1那么返回0，返回的第二个内容是匹配到的对象，第三个是读取的回显，如果没有匹配到任何东西，返回的是-1，第二个返回的对象是None,第三个返回的内容，有可能有，有可能为空</p></blockquote><h2 id="下发特殊命令"><a href="#下发特殊命令" class="headerlink" title="下发特殊命令"></a>下发特殊命令</h2><h3 id="下发ctrl-c"><a href="#下发ctrl-c" class="headerlink" title="下发ctrl+c"></a>下发ctrl+c</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tn.write(<span class="string">'\x03'</span>)</span><br></pre></td></tr></table></figure><p>对直接下发<code>\x03</code>就代表了ctrl+c</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-lib-时间处理</title>
      <link href="/2018/05/03/py-lib-time/"/>
      <url>/2018/05/03/py-lib-time/</url>
      <content type="html"><![CDATA[<p>本文主要记录了python处理时间的几个库的使用。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>时间戳一般在python里面是表示从1970年1月1日开始按秒计算的时间偏移量，通过<code>time.gmtime(0)</code>可以查看。</p><h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>世界协调时间，标准时间，中国是UTC+8</p><h3 id="DST"><a href="#DST" class="headerlink" title="DST"></a>DST</h3><p>夏令时</p><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br></pre></td></tr></table></figure><h3 id="time-1"><a href="#time-1" class="headerlink" title="time"></a>time</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.time() <span class="comment">#返回类似1525322407.005这种格式</span></span><br></pre></td></tr></table></figure><h3 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a>localtime</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.localtime()</span><br></pre></td></tr></table></figure><p>返回类似如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2018, tm_mon=5, tm_mday=3, tm_hour=12, tm_min=34, tm_sec=17, tm_wday=3, tm_yday=123, tm_isdst=0)</span><br></pre></td></tr></table></figure><p>返回的雷人分别表示 年 月 日 时 分 秒 一周的第几天(0表示周日) 一年中的第几天(从1开始) 是否是夏令时。</p><p>函数可以接收一个时间戳作为参数，返回对应的时间元组，默认是使用当前的时间戳作为参数。</p><h3 id="gmtime"><a href="#gmtime" class="headerlink" title="gmtime"></a>gmtime</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.gmtime()</span><br></pre></td></tr></table></figure><p>返回格式类似于<a href="#localtime"><code>localtime</code></a>，只不过<code>gmtime</code>返回的是UTC标准时间，<code>localtime</code>返回的是当前本地时间。<br>如果是中国的话，<code>gmtime</code>比<code>localtime</code>获取到的时间会小8个小时。</p><h3 id="strftime"><a href="#strftime" class="headerlink" title="strftime"></a>strftime</h3><p>格式化时间，第一个参数是格式化的格式，第二个参数是时间元组，比如<code>localtime</code>返回的时间，默认是<code>localtime</code>的返回值。</p><p>其中 %Y %m %d %H %M %S 分别表示年 月 日 时 分 秒</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>) <span class="comment">#返回'2018-05-03 14:01:57'</span></span><br></pre></td></tr></table></figure><h3 id="strptime"><a href="#strptime" class="headerlink" title="strptime"></a>strptime</h3><p>这个就是<code>strftime</code>的反向操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.strptime(<span class="string">'2018-05-03 14:01:57'</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br></pre></td></tr></table></figure><p>返回内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time.struct_time(tm_year=2018, tm_mon=5, tm_mday=3, tm_hour=14, tm_min=1, tm_sec=57, tm_wday=3, tm_yday=123, tm_isdst=-1)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.python.org/2/library/time.html" target="_blank" rel="noopener">https://docs.python.org/2/library/time.html</a><br><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">https://docs.python.org/2/library/datetime.html</a><br><a href="https://www.cnblogs.com/renpingsheng/p/6965044.html" target="_blank" rel="noopener">https://www.cnblogs.com/renpingsheng/p/6965044.html</a><br><a href="http://www.jb51.net/article/49326.htm" target="_blank" rel="noopener">http://www.jb51.net/article/49326.htm</a><br><a href="https://blog.csdn.net/tigerking1017/article/details/51332220" target="_blank" rel="noopener">https://blog.csdn.net/tigerking1017/article/details/51332220</a><br><a href="https://blog.csdn.net/u012175089/article/details/62044335" target="_blank" rel="noopener">https://blog.csdn.net/u012175089/article/details/62044335</a></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-字符串操作</title>
      <link href="/2018/05/02/py-lib-str/"/>
      <url>/2018/05/02/py-lib-str/</url>
      <content type="html"><![CDATA[<p>本文主要讲解一下python字符串的相关操作，包括string库的一些实用。</p><a id="more"></a><h2 id="常量字符串的操作"><a href="#常量字符串的操作" class="headerlink" title="常量字符串的操作"></a>常量字符串的操作</h2><p>常量字符串，就是我们定义的一个字符串，它们是一个常量，也就是不可改变的。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="string">"test_str"</span></span><br></pre></td></tr></table></figure><p>这里把常量字符串<code>test_str</code>赋值给了变量<code>var</code>，其中<code>test_str</code>这是一个不可改变的，<code>var</code>只是一个变量，可以被重新赋值。</p><h3 id="strip"><a href="#strip" class="headerlink" title="strip"></a>strip</h3><p><a href="https://docs.python.org/2/library/stdtypes.html#str.strip" target="_blank" rel="noopener">https://docs.python.org/2/library/stdtypes.html#str.strip</a><br><a href="https://docs.python.org/2/library/string.html#string.strip" target="_blank" rel="noopener">https://docs.python.org/2/library/string.html#string.strip</a></p><p>涉及到3个函数，<code>strip</code>, <code>lstrip</code>, <code>rstrip</code>，同理string库里面也有这3个函数，<code>strip</code>是复制当前字符串，把当前字符串的前后的特定的字符给去掉后返回一个新的字符串，默认去掉的字符是空格。<code>lstrip</code>是去掉左边特定的字符，<code>rstrip</code>是去掉右边的特定字符。<br>需要去掉的字符可以是多个，当遇到第一个不是去掉的字符的时候停止，比如’testxxxtest’要去掉里面的”test”几个字符，<code>strip</code>函数会匹配第一个t发现在去掉的字符中，e s t几个也在，所以都去掉，遇到了x不在test中则停止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">" test "</span>.strip() <span class="comment">#这里返回test</span></span><br><span class="line"><span class="string">"test"</span>.strip(<span class="string">'t'</span>) <span class="comment">#这里返回es</span></span><br><span class="line"><span class="string">"testxxxtest"</span>.strip(<span class="string">"test"</span>) <span class="comment">#这里返回xxx</span></span><br><span class="line"><span class="string">"mississippi"</span>.rstrip(<span class="string">"ipz"</span>) <span class="comment">#返回mississ</span></span><br><span class="line"><span class="string">"www.example.com"</span>.lstrip(<span class="string">"cmowz."</span>) <span class="comment">#返回example.com</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.strip(<span class="string">" test "</span>) <span class="comment">#返回test，其它几个使用类似</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p><a href="https://docs.python.org/2/library/stdtypes.html#str.split" target="_blank" rel="noopener">https://docs.python.org/2/library/stdtypes.html#str.split</a><br><a href="https://docs.python.org/2/library/string.html#string.split" target="_blank" rel="noopener">https://docs.python.org/2/library/string.html#string.split</a></p><p>这个函数是用于分割字符串，按照指定的字符把字符串分割，返回一个分割后的列表，同理也有<code>lsplit</code>和<code>rsplit</code>函数，同理string库里面也有相同的函数可以操作。</p><p>默认的分隔符是空格。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"1 2 3 4"</span>.split() <span class="comment">#返回['1', '2', '3', '4']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line">string.split(<span class="string">"1 2 3 4"</span>) <span class="comment">#返回['1', '2', '3', '4']</span></span><br></pre></td></tr></table></figure><h2 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h2><h3 id="s"><a href="#s" class="headerlink" title="%s"></a>%s</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"hello"</span> </span><br><span class="line">   </span><br><span class="line"><span class="comment">#%s打印时结果是hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%s"</span> % string   <span class="comment"># output: string=hello  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%2s意思是字符串长度为2，当原字符串的长度超过2时，按原长度打印，所以%2s的打印结果还是hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%2s"</span> % string   <span class="comment"># output: string=hello  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串左侧补空格，  </span></span><br><span class="line"><span class="comment">#所以%7s的打印结果是 hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%7s"</span> % string   <span class="comment"># output: string= hello  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%-7s意思是字符串长度为7，当原字符串的长度小于7时，在原字符串右侧补空格，  </span></span><br><span class="line"><span class="comment">#所以%-7s的打印结果是 hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%-7s!"</span> % string   <span class="comment"># output: string=hello !  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%.2s意思是截取字符串的前2个字符，所以%.2s的打印结果是he  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%.2s"</span> % string  <span class="comment"># output: string=he  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%.7s意思是截取字符串的前7个字符，当原字符串长度小于7时，即是字符串本身，  </span></span><br><span class="line"><span class="comment">#所以%.7s的打印结果是hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%.7s"</span> % string  <span class="comment"># output: string=hello  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%a.bs这种格式是上面两种格式的综合，首先根据小数点后面的数b截取字符串，  </span></span><br><span class="line"><span class="comment">#当截取的字符串长度小于a时，还需要在其左侧补空格  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%7.2s"</span> % string  <span class="comment"># output: string=   he  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%2.7s"</span> % string  <span class="comment"># output: string=hello  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%10.7s"</span> % string <span class="comment"># output: string=   hello  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#还可以用%*.*s来表示精度，两个*的值分别在后面小括号的前两位数值指定  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"string=%*.*s"</span> % (<span class="number">7</span>,<span class="number">2</span>,string)   <span class="comment"># output: string=   he</span></span><br></pre></td></tr></table></figure><h3 id="d"><a href="#d" class="headerlink" title="%d"></a>%d</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">num=<span class="number">14</span> </span><br><span class="line">   </span><br><span class="line"><span class="comment">#%d打印时结果是14  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%d"</span> % num      <span class="comment"># output: num=14  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%1d意思是打印结果为1位整数，当整数的位数超过1位时，按整数原值打印，所以%1d的打印结果还是14  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%1d"</span> % num      <span class="comment"># output: num=14  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数左侧补空格，所以%3d的打印结果是 14  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%3d"</span> % num      <span class="comment"># output: num= 14  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%-3d意思是打印结果为3位整数，当整数的位数不够3位时，在整数右侧补空格，所以%3d的打印结果是14_  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%-3d"</span> % num     <span class="comment"># output: num=14_  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%05d意思是打印结果为5位整数，当整数的位数不够5位时，在整数左侧补0，所以%05d的打印结果是00014  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%05d"</span> % num     <span class="comment"># output: num=00014  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%.3d小数点后面的3意思是打印结果为3位整数，  </span></span><br><span class="line"><span class="comment">#当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果是014  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%.3d"</span> % num     <span class="comment"># output: num=014  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%.0003d小数点后面的0003和3一样，都表示3，意思是打印结果为3位整数，  </span></span><br><span class="line"><span class="comment">#当整数的位数不够3位时，在整数左侧补0，所以%.3d的打印结果还是014  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%.0003d"</span> % num    <span class="comment"># output: num=014  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%5.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，再在左侧补空格，  </span></span><br><span class="line"><span class="comment">#规则就是补0优先，最终的长度选数值较大的那个，所以%5.3d的打印结果还是 014  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%5.3d"</span> % num     <span class="comment"># output: num= 014  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%05.3d是两种补齐方式的综合，当整数的位数不够3时，先在左侧补0，还是不够5位时，  </span></span><br><span class="line"><span class="comment">#由于是05，再在左侧补0，最终的长度选数值较大的那个，所以%05.3d的打印结果还是00014  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%05.3d"</span> % num    <span class="comment"># output: num=00014  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#还可以用%*.*d来表示精度，两个*的值分别在后面小括号的前两位数值指定  </span></span><br><span class="line"><span class="comment">#如下，不过这种方式04就失去补0的功能，只能补空格，只有小数点后面的3才能补0  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"num=%*.*d"</span> % (<span class="number">04</span>,<span class="number">3</span>,num) <span class="comment"># output: num= 014</span></span><br></pre></td></tr></table></figure><h3 id="f"><a href="#f" class="headerlink" title="%f"></a>%f</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math  </span><br><span class="line">   </span><br><span class="line"><span class="comment">#%a.bf，a表示浮点数的打印长度，b表示浮点数小数点后面的精度  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#只是%f时表示原值，默认是小数点后5位数  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%f"</span> % math.pi       <span class="comment"># output: PI=3.141593  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#只是%9f时，表示打印长度9位数，小数点也占一位，不够左侧补空格  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%9f"</span> % math.pi      <span class="comment"># output: PI=_3.141593  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#只有.没有后面的数字时，表示去掉小数输出整数，03表示不够3位数左侧补0  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%03.f"</span> % math.pi     <span class="comment"># output: PI=003  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够左侧补空格  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%6.3f"</span> % math.pi     <span class="comment"># output: PI=_3.142  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#%-6.3f表示小数点后面精确到3位，总长度6位数，包括小数点，不够右侧补空格  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%-6.3f"</span> % math.pi     <span class="comment"># output: PI=3.142_  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">#还可以用%*.*f来表示精度，两个*的值分别在后面小括号的前两位数值指定  </span></span><br><span class="line"><span class="comment">#如下，不过这种方式06就失去补0的功能，只能补空格  </span></span><br><span class="line"><span class="keyword">print</span> <span class="string">"PI=%*.*f"</span> % (<span class="number">06</span>,<span class="number">3</span>,math.pi)  <span class="comment"># output: PI=_3.142</span></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.jb51.net/article/134290.htm" target="_blank" rel="noopener">http://www.jb51.net/article/134290.htm</a></p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-with as 语句</title>
      <link href="/2018/05/02/python-withas/"/>
      <url>/2018/05/02/python-withas/</url>
      <content type="html"><![CDATA[<p>本文主要讲解了 with as 语句的使用，就是python里面上下文管理器的一种概念(context manager)。</p><a id="more"></a><p>官方链接：<br><a href="https://docs.python.org/2/reference/datamodel.html#context-managers" target="_blank" rel="noopener">https://docs.python.org/2/reference/datamodel.html#context-managers</a><br><a href="https://docs.python.org/2/reference/compound_stmts.html#the-with-statement" target="_blank" rel="noopener">https://docs.python.org/2/reference/compound_stmts.html#the-with-statement</a></p><p>我们知道平时打开文件进行操作使用如下语句，可以在任何时候都关闭掉打开的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.do_something()</span><br></pre></td></tr></table></figure><p>其实我们也可以创建自己的上下文管理器来完成相应的动作，在做完或者中间有异常的情况下，我们设定的代码都一定会执行。<br>我们只需要定义一个类，然后创建两个函数，格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">testwith</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_value, traceback)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'exit'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'fun'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> testwith() <span class="keyword">as</span> p:</span><br><span class="line">    p.fun()</span><br></pre></td></tr></table></figure><p>只要定义了<code>__enter__</code>和<code>__exit__</code>两个函数，那么就可以使用<code>with as</code>语句了，执行顺序如下：</p><ol><li>先执行<code>__init__</code></li><li>执行<code>__enter__</code>，返回的对象赋值给<code>with as</code>语句as后面的变量</li><li>执行<code>with as</code>的代码块(也就是执行p.fun())</li><li>执行<code>__enter__</code>，这个函数必须是4个参数，<code>self</code>是固定的，<code>exc_type</code>是异常类型，<code>exc_value</code>是异常实例对象，<code>traceback</code>是异常跟踪对象，如果没有异常发生，后面三个参数都是<code>None</code>。</li></ol><p><strong>注意</strong>: 如果在未执行代码块(也就是p.fun())以前发生了任何异常，是不会执行<code>__exit__</code>的，也就是说<code>__init__</code>或者<code>__enter__</code>里面发生了异常，是不会执行到<code>__exit__</code>里面的</p><p><strong>注意</strong>: 默认情况下<code>__exit__</code>返回的是<code>None</code>，这个时候，异常是会继续抛出的，如果想出现异常不抛出，这个函数需要显示的返回真值，比如<code>True</code>。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-lib-ConfigParser</title>
      <link href="/2018/05/02/py-lib-configparser/"/>
      <url>/2018/05/02/py-lib-configparser/</url>
      <content type="html"><![CDATA[<p>本文以python2.7版本为例进行ConfigParser基础进行解析，ConfigParser是python用于解析ini文件的库。</p><a id="more"></a><p>官方文档：<a href="https://docs.python.org/2/library/configparser.html" target="_blank" rel="noopener">https://docs.python.org/2/library/configparser.html</a></p><p>下面先看一下ini文件的格式，大致如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[SECTION1]</span></span><br><span class="line"><span class="attr">OPTION1</span> = VALUE1</span><br><span class="line"><span class="attr">OPTION2</span> = VALUE2</span><br><span class="line"></span><br><span class="line"><span class="section">[SECTION2]</span></span><br><span class="line"><span class="attr">OPTION3</span> = VALUE3</span><br><span class="line"><span class="attr">OPTION4</span> = VALUE4</span><br><span class="line"></span><br><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">OP</span> = DEFAULT1 #如果其它section没有提供这个option，默认使用这里的值</span><br></pre></td></tr></table></figure></p><h2 id="ConfigParser"><a href="#ConfigParser" class="headerlink" title="ConfigParser"></a>ConfigParser</h2><p>ConfigParser有几个类，下面先讲解它的ConfigParser这个类，首先引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ConfigParser <span class="keyword">import</span> ConfigParser <span class="keyword">as</span> cp</span><br></pre></td></tr></table></figure><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>然后实例化这个类并且读取init文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mycp = cp()</span><br><span class="line">cp.read(<span class="string">'your_ini_file.ini'</span>)</span><br></pre></td></tr></table></figure><h3 id="has-section"><a href="#has-section" class="headerlink" title="has_section"></a><code>has_section</code></h3><p>然后就可以使用如下的函数进行各种操作了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycp.has_section(<span class="string">'section'</span>) <span class="comment">#判断某个section是否在ini文件中</span></span><br></pre></td></tr></table></figure><h3 id="has-option"><a href="#has-option" class="headerlink" title="has_option"></a><code>has_option</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycp.has_option(<span class="string">'section'</span>, <span class="string">'option'</span>) <span class="comment">#判断在section中是否有某个option</span></span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycp.get(<span class="string">'section'</span>, <span class="string">'option'</span>) <span class="comment">#返回section下的option的值</span></span><br></pre></td></tr></table></figure><p>上面的<code>get</code>函数返回的是字符串，还有<code>getinit</code>, <code>getfloat</code>等可以返回整形和浮点型数据。</p><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a>sections</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mycp.sections() <span class="comment">#返回一个列表，包含ini文件的所有section，不包含default内容。</span></span><br></pre></td></tr></table></figure><h3 id="items"><a href="#items" class="headerlink" title="items"></a>items</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mycp.items(<span class="string">'section'</span>) <span class="comment">#返回一个列表，每个元素是一个包含两个元素的元组</span></span><br><span class="line"><span class="comment">#元组第一个元素是option内容，第二个是值，会获取default的内容。</span></span><br></pre></td></tr></table></figure><h3 id="重复的情况"><a href="#重复的情况" class="headerlink" title="重复的情况"></a>重复的情况</h3><p><strong>注意</strong>：如果有section的内容相同，取最后一个section里面的内容，如果section里面有option相同，取最后一个option的值。</p><h3 id="读取的值大小写问题"><a href="#读取的值大小写问题" class="headerlink" title="读取的值大小写问题"></a>读取的值大小写问题</h3><p>通过get等读取出来的值默认会被转换为小写，可以通过下面的方式屏蔽这个内容。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YouClassName</span><span class="params">(ConfigParser)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">optionxform</span><span class="params">(self, optionstr)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> optionstr</span><br></pre></td></tr></table></figure><p>通过继承ConfigParser并且重写optionxform函数，返回原始读取的内容。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-命令行</title>
      <link href="/2018/05/02/py-cmd/"/>
      <url>/2018/05/02/py-cmd/</url>
      <content type="html"><![CDATA[<p>本文主要备注一些python好用的命令行。</p><a id="more"></a><h2 id="编译py文件"><a href="#编译py文件" class="headerlink" title="编译py文件"></a>编译py文件</h2><p>当有一个py文件不能直接运行，但是需要查看语法等是否有误，可以使用如下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">py -m py_compile xx.py</span><br></pre></td></tr></table></figure><p>如果没有报错，不会有回显，并且会在xx.py对应目录下生成xx.pyc文件，如果有错，类似下面的回显：</p><p><img src="/2018/05/02/py-cmd/cmd_error1.png" alt="cmd_error1"></p><h2 id="pip相关命令"><a href="#pip相关命令" class="headerlink" title="pip相关命令"></a>pip相关命令</h2><h3 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h3><p>比如升级自己</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install --upgrade pip</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[hexo]-使用hexo+github搭建blog</title>
      <link href="/2018/04/28/tool-hexo-config/"/>
      <url>/2018/04/28/tool-hexo-config/</url>
      <content type="html"><![CDATA[<p>本文是在windows10下进行的配置。<br><a id="more"></a></p><p>参考链接：</p><ol><li><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">https://www.cnblogs.com/fengxiongZz/p/7707219.html</a></li><li><a href="https://www.jianshu.com/p/beb8d611340a" target="_blank" rel="noopener">https://www.jianshu.com/p/beb8d611340a</a></li></ol><h2 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h2><p>下载好node.js后安装完成后，输入如下命令表示成功：</p><p><img src="/2018/04/28/tool-hexo-config/nodejs.png" alt="nodejs"></p><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><p>下载好<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，安装完成后，输入如下命令表示成功：</p><p><img src="/2018/04/28/tool-hexo-config/git.png" alt="git"></p><p>如果命令失败，需要把git安装目录下的bin目录加入到环境变量里面，比如我的是：”c:/Program Files/Git/bin”，这个目录下有如下几个文件</p><p><img src="/2018/04/28/tool-hexo-config/git-bin.png" alt="git"></p><h2 id="github配置"><a href="#github配置" class="headerlink" title="github配置"></a>github配置</h2><p>进入<a href="https://github.com/" target="_blank" rel="noopener">github</a>注册一个账号，并且创建一个repository，注意名字必须是username.github.io格式，username是你注册的用户名。</p><p><img src="/2018/04/28/tool-hexo-config/github-repository.png" alt="gitbug"></p><p>可以通过<a href="https://username.github.io/的方式访问你的首页了。" target="_blank" rel="noopener">https://username.github.io/的方式访问你的首页了。</a></p><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>在任何适合的地方通过下面的命令安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><p>输入下面的命令，表示安装成功：</p><p><img src="/2018/04/28/tool-hexo-config/hexo-version.png" alt="hexo-version"></p><p>然后使用下面命令初始化hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>使用下面的命令安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>使用下面的命令生成页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>使用下面的命令启动服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p><img src="/2018/04/28/tool-hexo-config/hexo-server.png" alt="hexo-server"></p><p>根据提示访问这个网页，如果打不开，使用下面的命令修改端口号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000</span><br></pre></td></tr></table></figure><p>当然你可以启用debug信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s -p 5000 --debug</span><br></pre></td></tr></table></figure><p>有时候发现浏览器更新不及时，使用下面的命令清理缓存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>打开页面后出现下面的界面表示配置成功</p><p><img src="/2018/04/28/tool-hexo-config/hexo-succ.png" alt="hexo-succ"></p><h2 id="hexo与github关联"><a href="#hexo与github关联" class="headerlink" title="hexo与github关联"></a>hexo与github关联</h2><p>至于github上的权限等配置，这里不讲诉，本文只说明hexo与github的关联配置信息。</p><p>在我们刚刚操作的目录下有一个<code>_config.yml</code>文件，请在最后添加如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">    repository: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">      branch: master</span><br></pre></td></tr></table></figure><p>注意修改yourname为你自己的username</p><p>在发布以前需要安装下面的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>安装好以后使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>使用下面的命令可以重新生成页面(推荐使用这个命令)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>完成后，通过yourname.github.io就可以访问你的网页了。</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n name</span><br></pre></td></tr></table></figure><p>注意生成的文件在<code>source\_posts</code>这个目录下面，是一个md文件。</p><p>其中name替换成你想要的名字，会在<code>source\_posts</code>下生成你新建的文件，默认是md格式的，可以打开这个文件按照md的格式进行编写文章了。</p><p>如果需要图片支持，需要安装下面的插件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>以后使用hexo n命令的时候，会在文章<code>source\_posts</code>这里生成和你文件名对应的目录，文章里面使用md语法<code>![comt](name\xx.png)</code>的格式插入图片了。</p><h2 id="hexo配置文件"><a href="#hexo配置文件" class="headerlink" title="hexo配置文件"></a>hexo配置文件</h2><h3 id="根目录-config-yml配置"><a href="#根目录-config-yml配置" class="headerlink" title="根目录_config.yml配置"></a>根目录<code>_config.yml</code>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: Title</span><br><span class="line">subtitle:</span><br><span class="line">description:</span><br><span class="line">keywords:</span><br><span class="line">author:</span><br><span class="line">language: zh-CN <span class="comment">#语言，这个在theme\languages目录下的对应</span></span><br><span class="line">timezone: Asia/Shanghai <span class="comment">#时间</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">category_map:</span><br><span class="line">  PYTHON: python</span><br><span class="line">  ROBOTFRAMEWORK: robotframework</span><br><span class="line">  LINUX: linux</span><br><span class="line">  ENGLISH: english</span><br><span class="line">  DATABASE: database</span><br><span class="line">  TOOLS: tools</span><br><span class="line">  MARKDOWN: markdown</span><br><span class="line">  OTHER: other</span><br></pre></td></tr></table></figure><p>这里是每个文章的categories字段，生成对应的url，默认生成的是categories字段，如果这里面有中文，url里面也会包含中文，这里就可以对它进行映射，使url里面无中文。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: cactus <span class="comment">#配置主题，和theme下面的名字一样</span></span><br></pre></td></tr></table></figure><h3 id="theme下-config-yml配置"><a href="#theme下-config-yml配置" class="headerlink" title="theme下_config.yml配置"></a>theme下<code>_config.yml</code>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nav:</span><br><span class="line">  home: /</span><br><span class="line">  python: /categories/python</span><br><span class="line">  robotframework: /categories/robotframework</span><br><span class="line">  linux: categories/linux</span><br></pre></td></tr></table></figure><p>这里主要是对导航栏进行配置，注意我的主题是cactus，每个主题的配置有所不一样。</p><h3 id="文章里面的配置"><a href="#文章里面的配置" class="headerlink" title="文章里面的配置"></a>文章里面的配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: <span class="string">'[redis]-基本操作'</span> <span class="comment">#文章标题，可以和文件名不一样</span></span><br><span class="line">date: 2018-04-27 19:07:35 <span class="comment">#创建时间</span></span><br><span class="line">tags: <span class="comment">#tag</span></span><br><span class="line">categories: DATABASE <span class="comment"># 这里就是分类，可以使用[a, b]方式，表示多类</span></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt; <span class="comment">#有的主题会显示文章的全部内容，这里可以进行区分，后面的内容就不会默认显示在首页了。</span></span><br></pre></td></tr></table></figure><h2 id="在其它机器写文章"><a href="#在其它机器写文章" class="headerlink" title="在其它机器写文章"></a>在其它机器写文章</h2><p>我们现在所有的文件都是在当前机器上进行的，怎么换到其它机器上写文章呢。</p><p>我们在任意一个地方使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yourname/hexo-test.github.io.git</span><br></pre></td></tr></table></figure><p>注意替换相应的内容，克隆我们的服务器文件，<br>然后删除里面的所有内容，注意如果你开启了查看隐藏文件的功能，不要把<code>.git</code>这个文件删除<br>然后使用下面的命令创建一个分支，我们取名叫hexo，这个名字按照自己喜好命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br></pre></td></tr></table></figure><p>然后把你自己写文章的目录下的所有内容拷贝过来。</p><p>分别使用如下的命令进行提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"Create new branch(hexo)."</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --<span class="built_in">set</span>-upstream origin hexo</span><br></pre></td></tr></table></figure><p>这时候我们的github上就会多一个hexo分支，以后其它机器就可以通过下面的命令进行克隆代码，到其它机器写文章了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b hexo your_git_url</span><br></pre></td></tr></table></figure><p>注意以后写文章，提交到git，尽量使用下面的命令进行提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>本文以NexT为主题，进入的你站点目录下，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>进行安装，然后修改站点的config文件，修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>以后的配置都是在这个主题下进行配置。</p><h2 id="评论功能增加"><a href="#评论功能增加" class="headerlink" title="评论功能增加"></a>评论功能增加</h2>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[windows]-关闭win10自动更新</title>
      <link href="/2018/04/28/windows-close-auto-update/"/>
      <url>/2018/04/28/windows-close-auto-update/</url>
      <content type="html"><![CDATA[<p>windows10自动更新后，会重新电脑，按照下面方式关闭自动更新。<br><a id="more"></a><br><img src="/2018/04/28/windows-close-auto-update/close1.png" alt="close"><br><img src="/2018/04/28/windows-close-auto-update/close2.png" alt="close"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[redis]-基本操作</title>
      <link href="/2018/04/27/db-redis-basic/"/>
      <url>/2018/04/27/db-redis-basic/</url>
      <content type="html"><![CDATA[<p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。</p><a id="more"></a><p>桌面可视化工具可以使用 Redis Desktop Manager进行操作。</p><p>redis默认有db0 - db15 一共16个数据库。</p><p><img src="/2018/04/27/db-redis-basic/count.png" alt="count"></p><h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p><img src="/2018/04/27/db-redis-basic/hash.png" alt="count"></p><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p><img src="/2018/04/27/db-redis-basic/list.png" alt="count"></p><h2 id="str类型"><a href="#str类型" class="headerlink" title="str类型"></a>str类型</h2><p><img src="/2018/04/27/db-redis-basic/str.png" alt="count"></p><h2 id="set类型"><a href="#set类型" class="headerlink" title="set类型"></a>set类型</h2><p>还有zset类型</p><h2 id="命令行操作"><a href="#命令行操作" class="headerlink" title="命令行操作"></a>命令行操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select 4 <span class="comment">#选择db4这个数据库 select 0选择的就是db0这个数据库</span></span><br><span class="line"><span class="built_in">set</span> key value <span class="comment">#设置了key为字符串的值value</span></span><br><span class="line">keys * <span class="comment">#查看所有的key</span></span><br><span class="line">hmset mainkey name testname value testvalue <span class="comment">#设置了一个hash，key是mainkey，value里面是name:testname, value:testvalue</span></span><br><span class="line">hgetall mainkey <span class="comment">#返回mainkey对应的值</span></span><br><span class="line">lpush testlist v1 <span class="comment">#key是testlist，值是列表，增加了一个值v1</span></span><br><span class="line">lrange testlist 1 10 <span class="comment">#获取testlist的1-10之间的值</span></span><br></pre></td></tr></table></figure><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p><img src="/2018/04/27/db-redis-basic/namespace.png" alt="namespace"></p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-lib-virtualenv</title>
      <link href="/2018/04/27/py-virtualenv/"/>
      <url>/2018/04/27/py-virtualenv/</url>
      <content type="html"><![CDATA[<p>现在python有python2和python3两个版本，在windows上支持同时安装这两个版本的解释器，那么如何快速切换我们的开发环境呢。</p><a id="more"></a><p>首先如果只是作为调试，我们可以使用py -2和py -3命令来进入python的版本。</p><p><img src="/2018/04/27/py-virtualenv/py2-py3-console.png" alt="py2-py3-console"></p><p>同理，pip也支持：</p><p><img src="/2018/04/27/py-virtualenv/pip-console.png" alt="pip-console"></p><p>下面说一下virtualenv这个工具的使用，看下面的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:\Program Files&gt;virtualenv -p &quot;D:\Program Files\Python3\python.exe&quot; py3</span><br></pre></td></tr></table></figure><p>机器上安装了py2，在c:\python27下面，也安装了py3，在d:\program files\python3下面</p><p>现在使用上面的命令，会在在d:\program files\下面生成一个py3的文件夹，-p参数指定了这个环境的解释器版本</p><p>里面内容类似：</p><p><img src="/2018/04/27/py-virtualenv/py3-virtual.png" alt="py3-virtual"></p><p>我们进入scripts目录下执行active.bat：</p><p><img src="/2018/04/27/py-virtualenv/py3-active.png" alt="py3-active"></p><p>可以看见直接使用的是python命令，并且进入了python3的环境。注意上面的实际配置路径需要根据你自己机器上的路径配置。</p><p>virtualenv工具的作用就是创建一个独立的python开发环境，这里面的所有环境都是独立的，不会影响你原来的环境等信息(当然可以认为的修改)。</p><p>我们来看一下pip的使用：<br><img src="/2018/04/27/py-virtualenv/pip-virtual1.png" alt="pip-virtual"><br><img src="/2018/04/27/py-virtualenv/pip-virtual2.png" alt="pip-virtual"><br><img src="/2018/04/27/py-virtualenv/pip-virtual3.png" alt="pip-virtual"><br><img src="/2018/04/27/py-virtualenv/pip-virtual4.png" alt="pip-virtual"></p><p>红色区域1：在虚拟环境下进入python，引入一个click库，由于没有安装，所以引入失败<br>红色区域2：我们在虚拟环境下使用pip install click安装了click这个库，再次引入，成功了<br>红色区域3：调用deactive.bat退出当前的虚拟环境<br>红色区域4：进入系统的python3,引入click，引入失败，因为虚拟环境没有改变我们的外部环境</p><p>virtualenv还有很多的参数，通过：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv -h</span><br></pre></td></tr></table></figure></p><p>可以查看帮助信息</p><p>备注：<br>py.exe 可以在c:/Windows下找到<br>virtualenv.exe 可以在c:/Python27/Scripts下找到，当然根据你实际安装环境来决定位置</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[mysql]-mysql学习环境搭建</title>
      <link href="/2018/04/26/db-mysql-config/"/>
      <url>/2018/04/26/db-mysql-config/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了学习sql语句的环境配置，主要使用windows+xampp进行一键环境搭建，用于学习sql基本语句已经完全够用。</p><a id="more"></a><h2 id="xampp的配置"><a href="#xampp的配置" class="headerlink" title="xampp的配置"></a>xampp的配置</h2><p><a href="!https://www.apachefriends.org/zh_cn/index.html">xampp</a>是一个强大的建站集成软件包，里面包含了Apache, Mysql, PHP等常用的环境。而且支持Windows, Linux, Mac OS等环境，语言也支持中文。本文以windows为例进行配置。</p><p>下载好xampp以后，全部默认点击下一步就可以安装完成，默认一般安装在c:\xampp这个位置，桌面也会生成xampp的快捷方式，打开后类似如下界面：</p><p><img src="/2018/04/26/db-mysql-config/xampp-startup.png" alt="xampp-startup"></p><p>分别把Apache和MySQL启动起来，其它的不在本文讨论范围，启动后类似界面如下：</p><p><img src="/2018/04/26/db-mysql-config/xampp-mysql.png" alt="xampp-mysql"></p><p>点击MySQL的Admin，将会打开一个浏览器窗口，类似如下界面：</p><p><img src="/2018/04/26/db-mysql-config/xampp-phpmyadmin.png" alt="xampp-phpmyadmin"></p><p>其中红色框内的几个区域说明如下：<br>区域1：表示当前mysql数据库里面有哪些数据库<br>区域2：表示当前选中的数据库sks下面有哪些数据表<br>区域3和区域4：表示对选中的数据库进行SQL语句，也就是以后使用SQL语句进行增删查改操作的地方<br>区域5：最后执行</p><p>OK,经过上面的配置，基本的使用mysql来学习SQL语句已经可以满足要求了。</p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[robotframework]-指导说明</title>
      <link href="/2018/04/26/rf-user-guide/"/>
      <url>/2018/04/26/rf-user-guide/</url>
      <content type="html"><![CDATA[<p>robotframework使用手册，robotframework是一个自动化测试框架。</p><a id="more"></a><h2 id="基础实例"><a href="#基础实例" class="headerlink" title="基础实例"></a>基础实例</h2><h2 id="case的组织"><a href="#case的组织" class="headerlink" title="case的组织"></a>case的组织</h2><h3 id="运行前后的动作"><a href="#运行前后的动作" class="headerlink" title="运行前后的动作"></a>运行前后的动作</h3><p>在<code>__init__</code>文件中，可以在setting里面配置 <code>Suite Setup</code> 和 <code>Suite Teardown</code>分别表示执行测试套前执行的动作和执行完成测试套后需要执行的动作</p><p>在每个case文件中，同样也可以在setting部分配置上述内容， 但是是针对当前的case文件，里面还可以增加<code>Test Setup</code> 和 <code>Test Teardown</code>表示对每个case的执行前动作和执行后动作</p><p>在每个case里面，也可以增加<code>[Setup] [Teardown]</code>操作，和上面的<code>Test Setup</code> <code>Test Teardown</code>一个效果，但是如果都指定了，那么以case里面的，也就是<code>[Setup] [Teardown]</code>生效，外层的<code>Test Setup Test Teardown</code>不生效(也就是根本不会执行).</p><h2 id="运行命令"><a href="#运行命令" class="headerlink" title="运行命令"></a>运行命令</h2><h2 id="所有可用的设置"><a href="#所有可用的设置" class="headerlink" title="所有可用的设置"></a>所有可用的设置</h2><h2 id="内建库的常用函数"><a href="#内建库的常用函数" class="headerlink" title="内建库的常用函数"></a>内建库的常用函数</h2><h3 id="run-keyword-and-return"><a href="#run-keyword-and-return" class="headerlink" title="run keyword and return"></a>run keyword and return</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run keyword and <span class="built_in">return</span>  My Keyword  arg1 arg2 <span class="comment">#会运行My Keyword并且返回My Keyword的返回值</span></span><br></pre></td></tr></table></figure><h3 id="run-keyword-and-return-if"><a href="#run-keyword-and-return-if" class="headerlink" title="run keyword and return if"></a>run keyword and return if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run keyword and <span class="built_in">return</span> <span class="keyword">if</span>  <span class="variable">$&#123;rc&#125;</span> &gt; 0  My Keyword  arg1  arg2 <span class="comment">#当满足条件的时候运行My Keyword并且返回这个的返回值</span></span><br></pre></td></tr></table></figure><h3 id="run-keyword-if"><a href="#run-keyword-if" class="headerlink" title="run keyword if"></a>run keyword if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var1&#125;</span> =  run keyword <span class="keyword">if</span>  <span class="variable">$&#123;rc&#125;</span> == 0  Keyword1</span><br><span class="line">...  ELSE IF  0 &lt; <span class="variable">$&#123;rc&#125;</span> &lt; 42  Keyword2</span><br><span class="line">...  ELSE  <span class="variable">$&#123;rc&#125;</span></span><br></pre></td></tr></table></figure><p>${var1} 会根据指定的条件获取到指定的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;var2&#125;</span>  run keyword <span class="keyword">if</span>  condition  Keyword</span><br></pre></td></tr></table></figure><p>${var2} 获取到Keyword的值如果条件成立，否则获取到 None。</p><h3 id="append-to-list"><a href="#append-to-list" class="headerlink" title="append to list"></a>append to list</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@&#123;testlist&#125;  Create List</span><br><span class="line">Append To List  <span class="variable">$&#123;testlist&#125;</span>  v1 v2 <span class="comment">#注意了，这里必须使用$&#123;&#125;格式的变量，不能使用@&#123;&#125;格式变量</span></span><br></pre></td></tr></table></figure><p>当然这个keyword是在Collections这个内建库里面。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>robotframework里面的变量忽略大小写，下划线，以及空格，也就是说 <code>${var}  ${Var}  ${v_ar} ${v ar}</code>都是同一个变量，这个和keyword一样。</p><p>robotfframework里面有一般变量，列表，字典几种类型，分别用 <code>$ @ &amp;</code>修饰，但是其实它们并没有太多影响使用，也就是说一个列表<code>@{var}</code>，可以表示为<code>${var}</code>。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>使用<code>@{var}</code>的格式表明是一个列表，<code>@{var}[0]</code>的方式访问第一个元素。</p><h3 id="变量的优先级和作用域"><a href="#变量的优先级和作用域" class="headerlink" title="变量的优先级和作用域"></a>变量的优先级和作用域</h3><p>根据定义变量的方式有不同的作用域和优先级。</p><h4 id="变量的优先级-由高到底排序"><a href="#变量的优先级-由高到底排序" class="headerlink" title="变量的优先级(由高到底排序)"></a>变量的优先级(由高到底排序)</h4><p>内建变量 &gt; 执行测试设置的变量 &gt; 命令行 &gt; table表 &gt; resource或者variable文件引入</p><ol><li>内建变量，比如${TEMPDIR}拥有最高的优先级。</li><li>测试过程中产生的变量，比如使用set test/suite/global variable keywords产生的变量，<strong>会覆盖已经存在的在当前作用域内的变量</strong>(也就是说，如果一个case的variable里面有一个变量，先于这个case运行的任何文件里面使用了set global variable这个keyword的话，这个变量会被替换为global的值)，虽然优先级较高，但是不会影响作用域外的变量。</li><li>命令行变量，会覆盖variable table和资源文件里面的所有变量，命令行变量可以被设置多次，只有最后一个生效。</li><li>table表变量，可用于定义这个变量的文件的任意位置，会覆盖资源文件引入的变量。</li><li>资源文件变量，资源文件引入多个相同的变量，第一个引入的变量生效。</li></ol><h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><ol><li>全局作用域: 可以在全局任意一个地方可用，可以通过命令行和set global variable设置，当然也包括内建变量。</li><li>测试套作用域: 可以在当前测试套种使用的，比如当前测试文件引入的，当前文件的variable table里面定义的，或者 set suite variable定义的。</li><li>测试用例作用域: 可以在当前测试用例中使用，一般通过set test variable设置的。</li><li>本地作用域: 比如keyword的参数，keyword获得的返回值等。<h2 id="keyword"><a href="#keyword" class="headerlink" title="keyword"></a>keyword</h2><h2 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h2><h2 id="用户自定义测试库"><a href="#用户自定义测试库" class="headerlink" title="用户自定义测试库"></a>用户自定义测试库</h2></li></ol><h3 id="自定义测试lib接受列表"><a href="#自定义测试lib接受列表" class="headerlink" title="自定义测试lib接受列表"></a>自定义测试lib接受列表</h3><p>假如用python定义了一个自己的keyword，并且接受列表，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_lib</span><span class="params">(*this_is_list)</span>:</span></span><br></pre></td></tr></table></figure><p>那么在robotframework中需要使用如下格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_lib  a  b  c d</span><br></pre></td></tr></table></figure><p>注意参数空格，a和b都是前后两个空格，c和d之间只有一个空格，那么参数类似于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c d'</span>]</span><br></pre></td></tr></table></figure></p><h2 id="内部API"><a href="#内部API" class="headerlink" title="内部API"></a>内部API</h2><p>robotframework提供了很多内部api，这个是可以使用python获取java直接调用的函数。下面介绍一些常用的。<br>文档：<a href="http://robot-framework.readthedocs.io/en/v3.0.4/" target="_blank" rel="noopener">http://robot-framework.readthedocs.io/en/v3.0.4/</a></p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p>在<code>robot.api</code>这个包下的<code>logger</code>模块，如果要使用，需要引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> robot.api <span class="keyword">import</span> logger</span><br></pre></td></tr></table></figure><p><code>logger</code>模块有几个函数，<code>write</code>, <code>trace</code>, <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>console</code>，所有函数的第一个参数都是你想打印的信息，注意<code>console</code>只会打印到命令行里面，日志里面没有，<code>info</code>默认不会显示到命令行，但是有一个<code>also_console</code>参数，设置为<code>true</code>，即可以打印到控制台，也可以输出到日志。</p><p>具体参见：<a href="http://robot-framework.readthedocs.io/en/v3.0.4/autodoc/robot.api.html#module-robot.api.logger" target="_blank" rel="noopener">http://robot-framework.readthedocs.io/en/v3.0.4/autodoc/robot.api.html#module-robot.api.logger</a></p><h2 id="直接调用python函数"><a href="#直接调用python函数" class="headerlink" title="直接调用python函数"></a>直接调用python函数</h2><h3 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ret.decode(<span class="string">'utf-8'</span>)&#125; <span class="comment"># 这里ret是任意一个字符串，通过直接调用decode函数可以进行解码操作</span></span><br><span class="line"><span class="comment">#同理</span></span><br><span class="line">$&#123;ret.lower()&#125; <span class="comment">#可以直接返回小写</span></span><br></pre></td></tr></table></figure><h3 id="split函数"><a href="#split函数" class="headerlink" title="split函数"></a>split函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ret&#125;  Set Variable  $&#123;somestr.split(<span class="string">' '</span>)[<span class="number">0</span>]&#125;</span><br></pre></td></tr></table></figure><h3 id="调用random库"><a href="#调用random库" class="headerlink" title="调用random库"></a>调用random库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;ret&#125;  Evaluate  random.randint(<span class="number">1</span>, <span class="number">100</span>)  random</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> robotframework </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[英语语法]-英语语法简单入门</title>
      <link href="/2018/04/26/en-grammer/"/>
      <url>/2018/04/26/en-grammer/</url>
      <content type="html"><![CDATA[<p>本文主要记录了个人学习英语语法的一些备忘录。</p><a id="more"></a><h2 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h2><p>表语是紧跟系动词之后的结构，一般称及物动词之后的结构为宾语，系动词之后的结构为表语。<br>表语用来表述主语的身份，状态，特征等信息。</p><p>He looks good. look这里作为系动词，good是一个形容词，作为表语。</p><p>常用的系动词有：</p><blockquote><p>am/is/are keep seem appear become feel get grow remain smell look sound stay taste</p></blockquote><p>大多数情况，系动词也具有及物动词的词性，请看下面的两个keep：</p><h3 id="句1"><a href="#句1" class="headerlink" title="句1"></a>句1</h3><p>I <em>keep</em> silent in class.</p><h3 id="句2"><a href="#句2" class="headerlink" title="句2"></a>句2</h3><p>I <em>keep</em> books in my room.</p><h3 id="我们先看下系动词的两个特点"><a href="#我们先看下系动词的两个特点" class="headerlink" title="我们先看下系动词的两个特点"></a>我们先看下系动词的两个特点</h3><ol><li><strong>系动词后可以跟名词和形容词，而及物动词后只能跟名词</strong></li><li><strong>系动词在替换为be动词之后，句子语义基本不变</strong></li></ol><p>请看：</p><p>系动词之后接名词：<br>Adventure <em>becomes</em> a part of my life.<br>Pollution <em>remains</em> a troubling problem.</p><p>系动词之后接形容词(一般及物动词不具有这个特性)：<br>She <em>looks</em> a little tired.<br>The shop <em>stays</em> open.</p><p>系动词替换为be动词之后，语义基本不变：<br>Adventure <em>is</em> a part of my life.<br>She <em>was</em> a little tired.</p><p>好，现在来看<a href="#句1">句1</a>和<a href="#句2">句2</a>的比较：<br>根据<a href="#我们先看下系动词的两个特点">系动词特点</a>1，可以发现<a href="#句1">句子1</a>中的<em>keep</em>肯定是系动词，应为silent是形容词，及物动词不具有这个特性。<br>那么根据<a href="#我们先看下系动词的两个特点">特点1</a>无法判断<a href="#句2">句子2</a>的<em>keep</em>属性，因为book是一个名词，系动词和及物动词都有这个特性，那么根据<a href="#我们先看下系动词的两个特点">特点2</a>进行判断，把<em>keep</em>替换为be动词查看语义是否变化：<br>I is books in my room.显然这个句子是有歧义的，那么就不是系动词，因为替换后的语义都变化了，所以这里也不能进行替换，那么<em>keep</em>就是一个及物动词。i</p><h2 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h2><p>定语是一个广义的概念，其本质是形容词词性，可以修饰名词和代词。</p><h2 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h2><p>类似于定语，是一个广义的概念，本质是副词词性，可以修饰除了名词和代词以外的结构，比如动词，形容词，副词</p><h2 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h2><p>补语是对宾语的补充说明。</p><p>中文的补语：有一类动词可以改变宾语的动作或者状态，例如： 我要求学生们去学习跳舞，要求这个动词后面是宾语学生们，如果省略了补语，变成了我要求学生们，这句话显然句子意义不完整，宾语加上补语，可以单独成句，并且意义变换不大，学生们去学习跳舞。</p><p>英语的补语也类似， I have my hair dyed. have在这里表示 使得，把 的意思， I have my hair去掉补语句子意义不完整，my hair be dyed, 句子意义基本不变。</p><p>其实补语是由名词从句省略得来的。</p><p>I found that the homework was difficult.<br>I found the homework difficult.</p><p>形容词，不定式，分词等结构都可以作为补语。</p><h2 id="注意每个单词的词性"><a href="#注意每个单词的词性" class="headerlink" title="注意每个单词的词性"></a>注意每个单词的词性</h2><p>比如 more than 这个词组</p><p>首先我们看一下more这个词通过字典查出来的词性：</p><p><img src="/2018/04/26/en-grammer/more.png" alt="more"></p><p>We had more than they did. 这里的more是名词，<code>更多</code>的意思</p><p>We had more food that they did. 这里的more是形容词，修饰food，表示<code>更多的</code>的意思</p><p>We talked more than they did. 这里的more是副词，修饰talk，表示<code>更多</code>的意思</p><h2 id="语法框架"><a href="#语法框架" class="headerlink" title="语法框架"></a>语法框架</h2><p>名词：主 宾 表 补<br>形容词：定 表 补<br>副词： 状<br>动词： 谓</p><p>英语中绝大部分句子是由 “<strong>四大词性</strong>“ 和 “<strong>七类辅助结构</strong>“构成的，也就是 名词 形容词 副词 动词 和 介词短语 名词从句 定语从句 状语从句 动名词 分词 不定式。</p><p><img src="/2018/04/26/en-grammer/en1.png" alt="english"></p><h2 id="英语时态"><a href="#英语时态" class="headerlink" title="英语时态"></a>英语时态</h2><p>时间： 过去 现在 将来</p><p>状态： 一般 进行 完成(对之前发生的状态的总结) 进行完成(对正在进行的动作的总结)</p><p><img src="/2018/04/26/en-grammer/shitai.png" alt="en-grammer"></p><p><img src="/2018/04/26/en-grammer/shitai2.png" alt="en-grammer"></p><h2 id="虚拟语气"><a href="#虚拟语气" class="headerlink" title="虚拟语气"></a>虚拟语气</h2><h3 id="wish句型"><a href="#wish句型" class="headerlink" title="wish句型"></a>wish句型</h3><p>对现在发生的动作，只需要把动词改为一般过去时即可。</p><p>I wish that you were my brother.</p><p>对过去发生的动作， 过去完成时。</p><p>I wish that he had not failed the exam.</p><p>对将来发生的动作，加入情态动词would could might should等即可。</p><p>I wish that I could land on the Mars tomorrow.</p><h3 id="If-Then-句型"><a href="#If-Then-句型" class="headerlink" title="If Then 句型"></a>If Then 句型</h3><p>其中If引导的是从句，then引导的是主句，有时候then也可以省略</p><p>也分为下面三种情况：</p><p>对现在发生的：</p><p>if 主语 过去式， then 主语 would等几个情态动词 + 动词原型</p><p>If I knew that, I would tell you.</p><p>对过去发生的：</p><p>If 主语 过去完成， then 主语 would等几个情态动词 + 现在完成时</p><p>If I had worked hard, I might have passed the exam.</p><p>对将来发生的：</p><p>If 主语 were to/should 动词原型， then 主语 would等几个情态动词 动词原型</p><p>If she should come, I would ask her for help.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于wish和if then句型，首先从句都是一样的结构，因为wish中that后面的也是从句，都是对现在的虚拟用过去式，对过去的虚拟用过去完成时，对将来的虚拟，使用情态动词+原型，<br>对于if then句型，主句只需要在从句的基础上加上would等情态动词即可。</p><p>对于if then句型，如果主句，也就是if使用了情态动词would could should might中任意一个，那么就是虚拟语气，也就需要注意主句的时态</p><blockquote><p>另外，主从据可以表达不同时间的虚拟 If they had set off yesterday, they would be here now. 意思是如果他们昨天出发，现在应该到这里了，也就是说他们昨天没有出发，现在也没有到这里，if从句是对过去的虚拟，then主句是对现在的虚拟，再看： If we shouldn’t have an date this afternoon, I would go shopping now. 意思是如果不是下午有个约会，我现在已经去逛街了，也就是说，我们下午有个约会，现在我并没有去逛街。</p></blockquote><h2 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h2><p>主要有以下5类句型， 其中S主语 V谓语 O宾语 P表语 C补语</p><p>S V</p><p>S V O</p><p>S V O O</p><p>S V P</p><p>S V O V</p><h3 id="简单句的区分"><a href="#简单句的区分" class="headerlink" title="简单句的区分"></a>简单句的区分</h3><p>S V O diff S V P</p><p>首先回忆一下，系动词后面可以接表语，而且形容词和名称可以作为表语，并且S V P结构中 V 这个系动词替换为be动词后，语义基本不变。</p><p>Tom got angry. angry是adj， S V P</p><p>Tom got a fish. fish是n，got替换为be，Tom was a fish 明显语义不对，所以是 S V O</p><p>Tom becomes a real man. man是n，got替换为be， Tom is a real man. 正确，所以是 S V P</p><p>S V O O diff S V O C</p><p>也有两种方法区分：</p><p>O 这个宾语只能是名词</p><p>省略主语与谓语，在O和另外一个结构，也就是还无法区分是O 还是 C的之间加入be动词，如果结构完整，并且意思基本一致，那么就是 S V O C，因为C 是对O的补充说明，句子意思应该完整。</p><p>She puts apples <em>on the wooden dining table</em>. 介词短语无法充当名词，所以是 S V O C</p><p>I think my brother <em>a clever boy</em>. 这里是名词，根据第二个方法 my brother is a clever boy. 句子意思基本一致，所以是 S V O C</p><p>Mohter made my brother <em>a black sweater</em>. 这里是名词，根据第二个方法，my brother is a black sweater。 明显句子意思不对，所以是S V O O</p><p>另外补语C如果省略了得话，句子意思会不完整，比如上面的She puts apples， I think my brother，省略了补语后，句子意思都不完整。</p><p>I found the homework difficult.</p><p>She heard Jean singing.</p><h2 id="副词的用法"><a href="#副词的用法" class="headerlink" title="副词的用法"></a>副词的用法</h2><p>形容词修饰名词和代词，副词则是修饰除了名词和代词以外的词，比如修饰动词，形容词，副词，介词<br>短语，不定式等</p><p>副词分为三大类，dis分类，ad附属，con连接</p><p>dis: 比如Clearly, we have got the trophy(很明显，我们拿到了奖杯) 其中Clearly修饰的是句子<br>ad: She knows me well. well 修饰动词knows<br>con: 连接两个句子， I’d like to help you. However, my hands are full.</p><p>adv的位置：<br>修饰动词： 位于动词之前，需要挨着动词 The guests loudly laughed. loudly在laughed之前<br>位于动词之后，可以不挨着。 The guests laughed loudly.这里挨着<br>She knows me well. well没有挨着knows</p><p>修饰形容词：一般adv位于adj之前，并且挨着 John had a very beautiful daughter. very 修饰beautiful</p><p>修饰adv： 需要挨着，并且前面的一个adv修饰后面一个adv<br>She played piano very well. very 修饰well</p><p>修饰其它结构：比如短语，不定式，句子等，adv需要位于被修饰结构之前</p><p>The number is well above the March average. well修饰介词短语above<br>I’m here just to make up the number. just修饰不定式to</p><p>总结： adv一般位于被修饰的结构之前，并且紧邻，如果修饰动词，可以在动词之后，而且可以不挨着</p><p>特殊的一些adv<br>前面说adv不可以修饰名词和代词<br>但是，一些adv可以用于强调名词和代词<br>比如： Only you can think of yourself. Only 强调you<br>We need to evaluate even the worst outcome. even修饰后面的outcome</p><p>此类adv有 only even just等<br>下面的几个作为强调，必须要使用逗号与主句分离<br>We need of medical workers, especially surgeons. especially用于强调surgeons，用逗号和主句分离<br>此类副词有 especially, particularly, notably, namely等</p><h2 id="副词类结构"><a href="#副词类结构" class="headerlink" title="副词类结构"></a>副词类结构</h2><p>在七类辅助结构中(介词短语，不定式，分词，动名词，名词从句，定语从句，状语从句)中有4类结构可以作为副词使用，分别是介词短语，状语从句，分词，不定式</p><p>它们和副词一样，有三类用法，disjunct(分离) adjunct(附属)　conjunct(连接) 三种</p><p>四类结构都可以作为dis</p><p>With your help, we will finish the task on time.</p><p>To finish the project, the stated up all night.</p><p>Because the asked me to do it, I did it.</p><p>Followed by his dog, the hunter walked slowly in the forest.</p><p>除了状语从句以外，其它三类结构都可以作为ad修饰v 和 adj，必须位于被修饰对象后面，必须和adj紧邻，但是v却可以不用。</p><p>The guide led us through the forest. We are ready for the challenges.</p><p>He used his influence to support us. I am glad to meet you.</p><p>I spent two weeeks writing the essay.</p><p>只有介词短语可以作为 con</p><p>The won’t back before five o’clock. In other word, you’ll have to wait for nearly three hours.</p><blockquote><p>副词位置总结： 作为ad的时候才有位置的概念，其中一般的adv，只有修饰v的时候，可以放在v的后面，并且位置可以不紧邻，其它情况(包括位于v之前)都必须紧邻被修饰的结构，但是另外三种副词结构(不定式，分词，介词短语)修饰v和adj的时候，放在被修饰对象的后面，同样，修饰v的时候，位置可以不紧邻，其它情况都需要紧邻。</p></blockquote><h3 id="注意副词的垂悬修饰"><a href="#注意副词的垂悬修饰" class="headerlink" title="注意副词的垂悬修饰"></a>注意副词的垂悬修饰</h3><p>先看逻辑主语</p><p>Hearing their teacher’s voice, the pupils stopped talking at once.</p><p>现在分词Hearing their teacher’s voice 作为状语，作为dis中有谓语hear,宾语their teacher’s voice。缺少了主语，其实主语是被省略了的，为什么可以省略，因为和主句的the pupils是相同的，所以省略了。这个就是逻辑主语</p><p>所有的非谓语动词(动名词，不定式，分词)都存在逻辑主语。</p><p>如果一个分词的逻辑主语与主句的主语不相同，这个就叫做垂悬修饰，这是在英语中绝对不能出现的。</p><p>Opening the window, stars were calling my name. 如果补足主语 Stars were opening the window，可以看见，这句表达式错误的，其实修改为下面的句式就正确了</p><p>Opening the window, I heard stars calling my name.</p><p>同理下面的句子</p><p>To play tennis well, the racket(拍子) should be held properly.是错误的，改为</p><p>To play tennis well, you should hold the racket properly.就是正确的了。</p><h2 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h2><h3 id="形容词的位置"><a href="#形容词的位置" class="headerlink" title="形容词的位置"></a>形容词的位置</h3><p>形容词只能修饰n和代词(不能修饰普通代词，比如He)，一般位于被修饰对象的前面，但是如果代词是复合代词(比如somethin)需要位于其之后。</p><h3 id="四类辅助结构作定语"><a href="#四类辅助结构作定语" class="headerlink" title="四类辅助结构作定语"></a>四类辅助结构作定语</h3><p>介词短语，后于名词/代词之后 We are taking care of kids from the slum(平民窟).</p><p>定于从句，同上，The village where I was born was very small.</p><p>分词，同上， The book bought from the bookstore is very interesting.</p><p>不定式，同上， He is the man to go.</p><p>可以看见，一般的adj是位于被修饰对象的前面，但是四类辅助结构都是放在被修饰对象的后面，为什么这里和中文差异这么大呢，因为中文里面有一个万能的’的’结构，但是英语里面没有这个结构</p><p>正确的用法： He gave apples in the basket to me.  错误的用法： He gave in the basket apples to me.</p><h2 id="位置总结"><a href="#位置总结" class="headerlink" title="位置总结"></a>位置总结</h2><p>下面的总结是对于一般情况而言。</p><p>形容词修饰名词和代词(普通代词不用修饰)</p><p>副词修饰除了名词和代词以外的词，包括形容词，副词，动词，不定式，分词，介词短语等</p><p>一般副词，位于被修饰对象之前，并且紧邻，如果修饰动词，可以在动词之后，并且位置可以不紧邻。</p><p>一般形容词，位于被修饰对象之前，并且紧邻，但是修饰复合代词，一般位于符合代词之后。</p><p>副词结构，状语从句，介词短语，不定式，分词， 只有在作为ad，也就是附加的情况下有位置的区分，需要位于被修饰对象后面，如果修饰动词，可以不紧邻</p><p>形容词结构，定于从句，介词短语，不定式，分词， 一般位于被修饰对象的后面，并且紧邻。</p><p>在总结： 一般词，位于被修饰对象的前面，结构性词，位于被修饰对象的后面。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/adingdemao" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/adingdemao</a></p>]]></content>
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[python]-字典的使用</title>
      <link href="/2018/04/26/py-dict/"/>
      <url>/2018/04/26/py-dict/</url>
      <content type="html"><![CDATA[<p>本文以python3.6.5本本为例。</p><a id="more"></a><h2 id="字典基础操作"><a href="#字典基础操作" class="headerlink" title="字典基础操作"></a>字典基础操作</h2><h3 id="判断key是否在字典中"><a href="#判断key是否在字典中" class="headerlink" title="判断key是否在字典中"></a>判断key是否在字典中</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: test_dict</span><br><span class="line">Out[<span class="number">2</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">if</span> <span class="string">'a'</span> <span class="keyword">in</span> test_dict:</span><br><span class="line">   ...:     print(<span class="keyword">True</span>)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="遍历字典的key"><a href="#遍历字典的key" class="headerlink" title="遍历字典的key"></a>遍历字典的key</h3><p>方式一：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> test_dict:</span><br><span class="line">    ...:     print(i, end=<span class="string">' '</span>)</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure></p><p>方式二：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: <span class="keyword">for</span> i <span class="keyword">in</span> test_dict.keys():</span><br></pre></td></tr></table></figure></p><blockquote><p>注意python3里面没有iterkeys()这个函数了。</p></blockquote><h3 id="获取字典的值"><a href="#获取字典的值" class="headerlink" title="获取字典的值"></a>获取字典的值</h3><h4 id="get-key-value-None"><a href="#get-key-value-None" class="headerlink" title="get(key, value=None)"></a>get(key, value=None)</h4><p>有一种情况，当字典存在某个key时，把key对应的值赋值给某个变量，当不存在这个key时，这个变量获得None值。使用dict.get()方法可以完成这个逻辑。<br>get方法接收两个参数，第一个是需要判定的key，第二个是如果key不存在时此方法返回的值，默认值是None，函数返回key对应的值或者第二个参数的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">27</span>]: test_dict</span><br><span class="line">Out[<span class="number">27</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: test_dict.get(<span class="string">'a'</span>) <span class="comment">#'a'这个key在字典中，所以返回实际的值</span></span><br><span class="line">Out[<span class="number">28</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: test_dict.get(<span class="string">'d'</span>, <span class="number">4</span>) <span class="comment">#'d'这个key不在字典中，所以返回第二个参数的值4</span></span><br><span class="line">Out[<span class="number">29</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: print(test_dict.get(<span class="string">'e'</span>)) <span class="comment">#'e'这个key不在字典中，没有提供第二个参数，返回None</span></span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><h4 id="setdefault-key-value-None"><a href="#setdefault-key-value-None" class="headerlink" title="setdefault(key, value=None)"></a>setdefault(key, value=None)</h4><p>当key存在于字典中，那么返回这个key对应的值，如果不存在，则设置字典的key为对应的value，并且返回vlaue。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">31</span>]: test_dict</span><br><span class="line">Out[<span class="number">31</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">32</span>]: test_dict.setdefault(<span class="string">'a'</span>, <span class="number">3</span>)</span><br><span class="line">Out[<span class="number">32</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">33</span>]: test_dict</span><br><span class="line">Out[<span class="number">33</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">34</span>]: test_dict.setdefault(<span class="string">'d'</span>, <span class="number">4</span>)</span><br><span class="line">Out[<span class="number">34</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: test_dict</span><br><span class="line">Out[<span class="number">35</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: test_dict.setdefault(<span class="string">'d'</span>)</span><br><span class="line">Out[<span class="number">36</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: test_dict.setdefault(<span class="string">'e'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: test_dict</span><br><span class="line">Out[<span class="number">38</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'e'</span>: <span class="keyword">None</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="同时遍历key和value"><a href="#同时遍历key和value" class="headerlink" title="同时遍历key和value"></a>同时遍历key和value</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">42</span>]: test_dict</span><br><span class="line">Out[<span class="number">42</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'e'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: <span class="keyword">for</span> k, v <span class="keyword">in</span> test_dict.items():</span><br><span class="line">    ...:     print(k, v)</span><br><span class="line">    ...:</span><br><span class="line">a <span class="number">1</span></span><br><span class="line">b <span class="number">2</span></span><br><span class="line">c <span class="number">3</span></span><br><span class="line">d <span class="number">4</span></span><br><span class="line">e <span class="keyword">None</span></span><br></pre></td></tr></table></figure><blockquote><p>注意： python3已经没有iteritems()函数。</p></blockquote><h2 id="字典视图对象"><a href="#字典视图对象" class="headerlink" title="字典视图对象"></a>字典视图对象</h2><p>字典视图可以动态反馈字典的各种修改。</p><p>使用dict.keys(), dict.values(), dict.items()返回的就是字典的视图对象。</p><blockquote><p>python2里面是通过dict.viewkeys(), dict.viewvalues(), dict.viewitems()返回的字典视图对象。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">44</span>]: test_dict</span><br><span class="line">Out[<span class="number">44</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>, <span class="string">'e'</span>: <span class="keyword">None</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: keys = test_dict.keys()</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: keys</span><br><span class="line">Out[<span class="number">46</span>]: dict_keys([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: values = test_dict.values()</span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: values</span><br><span class="line">Out[<span class="number">48</span>]: dict_values([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="keyword">None</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: len(keys)</span><br><span class="line">Out[<span class="number">49</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: test_dict.setdefault(<span class="string">'f'</span>, <span class="number">6</span>)</span><br><span class="line">Out[<span class="number">50</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: len(keys)</span><br><span class="line">Out[<span class="number">51</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: keys</span><br><span class="line">Out[<span class="number">52</span>]: dict_keys([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br></pre></td></tr></table></figure><h2 id="lib-OrderedDict"><a href="#lib-OrderedDict" class="headerlink" title="lib-OrderedDict"></a>lib-OrderedDict</h2><p>我们知道，dict是无序的，也就是说我们插入数据以后，我们的数据在dict里面是无序的，不是按照插入的顺序排列的，python提供了OrdereDict这个类，保证了dict是按照我们插入的顺序排列的。</p><p>使用之前需要引入：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDcit</span><br></pre></td></tr></table></figure></p><p>使用方法和一般字典使用方法一致。注意函数popitem()的使用。</p><h3 id="popitem"><a href="#popitem" class="headerlink" title="popitem()"></a>popitem()</h3><p>在一般字典中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict.popitem()</span><br></pre></td></tr></table></figure></p><p>返回(key, value)并且从字典中移除这一队值，注意，这里移除是任意的，不确定移除谁，因为dict是无序的。如果字典是空，这里将抛出KeyError异常</p><p>在OrderedDict中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord.popitem(last=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p><p>这里有一个参数last，默认是True，表示移除最后一个元素，如果为False，则移除第一个元素，这里移除的内容就一定是确定的。同理，字典为空，抛出KeyError异常。</p><h3 id="move-to-end"><a href="#move-to-end" class="headerlink" title="move_to_end()"></a>move_to_end()</h3><p>OrderdDict多了一个<code>move_to_end</code>函数，有两个参数，第一个参数是待移动的key，第二个参数表示移动到最后(True默认值)还是移动到开头(False)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ord.move_to_end(key, last=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><p>同理，如果key不存在，抛出KeyError错误。</p><h2 id="lib-defaultdict"><a href="#lib-defaultdict" class="headerlink" title="lib-defaultdict"></a>lib-defaultdict</h2><p>是dict的子类，但是提供了一个参数用于初始化字典的key对应的值</p><p>同样需要先引入<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br></pre></td></tr></table></figure></p><p>结构如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaultdict(default_factory=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p><p>使用实例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">92</span>]: a = defaultdict(list)</span><br><span class="line">In [<span class="number">95</span>]: a[<span class="string">'a'</span>]</span><br><span class="line">Out[<span class="number">95</span>]: []</span><br></pre></td></tr></table></figure></p><p>上面定义了一个defaultdict实例a，并且参数是list，我们并没有定义a的key ‘a’，但是后面直接使用a[‘a’]并没有报错，而是直接输出了一个空的列表。也就是说如果默认情况下，使用一个不存在的key，defaultdict会创建这个key，并且赋初始值为<code>default_factory</code>。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[linux]-vim</title>
      <link href="/2018/04/26/linux-vim/"/>
      <url>/2018/04/26/linux-vim/</url>
      <content type="html"><![CDATA[<p>本文主要记录常用的一些vim操作。</p><a id="more"></a><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><p>y 是复制命令<br>p 是粘贴命令<br>d 是剪切命令<br>v 是选中命令</p><p>可以结合下面几个参数进行操作，下面用y复制命令说明，其它几个命令类似</p><p>yw 复制一个单词<br>yy 复制一行<br>y$ 复制到行尾<br>y^ 复制到行首<br>yG 复制到文件尾<br>y1G 复制到文件首</p><h2 id="取消上一步操作"><a href="#取消上一步操作" class="headerlink" title="取消上一步操作"></a>取消上一步操作</h2><p>直接输入<code>:u</code> 即可</p><h2 id="快速跳转"><a href="#快速跳转" class="headerlink" title="快速跳转"></a>快速跳转</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>gg 快速回到文件首部<br>GG 快速回到文件尾部</p><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>在普通模式下，直接按<code>ma</code>，可以在当前光标所在行设置一个标记a，在其它地方使用<code>&#39;a</code>可以快速回到这里，类似<code>less</code>命令的标记。</p><h2 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h2><p>在命令模式下(也就是输入<code>:</code>这个的情况下)，输入<code>set number</code>即可</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="忽略大小写"><a href="#忽略大小写" class="headerlink" title="忽略大小写"></a>忽略大小写</h3><p>在命令行模式下输入<code>set ignorecase</code>即可，要恢复大小写匹配，输入<code>set noignorecase</code></p><h2 id="文本替换"><a href="#文本替换" class="headerlink" title="文本替换"></a>文本替换</h2><h3 id="全文替换"><a href="#全文替换" class="headerlink" title="全文替换"></a>全文替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/old/new/g</span><br></pre></td></tr></table></figure><h2 id="文本查找"><a href="#文本查找" class="headerlink" title="文本查找"></a>文本查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/search_key</span><br></pre></td></tr></table></figure><p>n查找下一个，N查找上一个。</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[Linux]-文件查看操作</title>
      <link href="/2018/04/26/linux-view-file/"/>
      <url>/2018/04/26/linux-view-file/</url>
      <content type="html"><![CDATA[<p>本文主要对Linux下查看文件的几个命令的常用方式进行了总结，没有进行详细解释，适合作为查阅，备忘。</p><a id="more"></a><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>一次显示整个文件，参数:</p><p>-n: 输出行号<br>-b: 输出行号，但是忽略空白行</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><p>每次显示一屏内容</p><p>按键：<br>enter 下一行<br>space 下一屏<br>= 显示当前行号<br>:f 显示当前文件和行号<br>ctrl+b 上一屏(对应的ctrl+f下一屏)</p><p>参数：<br>+num 从num行开始显示<br>-num 每屏显示num行<br>+/pattern 从第一个匹配pattern的前两行开始显示</p><p>举例：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ more +10 file</span><br><span class="line">$ more -10 file</span><br><span class="line">$ more +10 -10 file</span><br><span class="line">$ more +/<span class="built_in">test</span> -10 file</span><br></pre></td></tr></table></figure></p><h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>类似于<a href="#more">more</a>，但是less支持使用page down 和 page up进行翻页。<br>less 和 more 都支持v命令直接调用vim编辑器，都支持-s参数把多个连续的空行显示为一行。</p><p>按键：<br>enter 下一行<br>y 上一行<br>g 调到最开始<br>G 调到最末尾<br>n 显示下一个搜索的匹配<br>N 显示上一个搜索的匹配<br>m 输入以后会提示输入标记，比如输入a，那么当浏览到其它内容以后，想回到a这个标记点，输入’a就可以了</p><p>参数：<br>-i 文章内进行搜索的时候忽略大小写<br>-N 显示行号<br>-M 显示读取进度，显示内容类似：<code>iperft lines 19-48/1836 3%</code> 分别表示文件名iperft，当前屏幕显示的是19-48行，总共1836行</p><h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>默认显示文件的前10行，-n num参数可以指定显示多少行，这个参数对<a href="#tail">tail</a>命令也适用。</p><h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>默认显示文件的最后10行</p><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>可以进行字符匹配，-i 忽略大小写， -n 显示行号， -v 反向匹配</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep -i <span class="built_in">test</span> file</span><br><span class="line">$ grep -ni <span class="built_in">test</span> file</span><br><span class="line">$ ps -ef | grep firefox -v grep</span><br></pre></td></tr></table></figure><h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>计算byte，字数或者列数</p><p>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll | wc -l <span class="comment">#显示ll命令回显有多少行</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>[SQL]-sql基础</title>
      <link href="/2018/04/25/db-sql-basic/"/>
      <url>/2018/04/25/db-sql-basic/</url>
      <content type="html"><![CDATA[<p>本文主要介绍了sql(Structured Query Language)语句的基本使用，主要使用mysql进行操作。桌面可视化工具可以使用HeidiSQL或者Navicat。</p><a id="more"></a><p>参考链接:</p><ul><li><a href="http://www.w3school.com.cn/sql/" target="_blank" rel="noopener">http://www.w3school.com.cn/sql/</a></li></ul><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>数据库是数据的容器，在做任何有关数据的操作时，都需要创建一个数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] database_name;</span><br></pre></td></tr></table></figure><p>注意 <code>IF NOT EXISTS</code>语句是可选的，这句话的意思是如果在服务器已经有了和当前需要创建的数据库同名的数据库，就不创建。</p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>mysql等数据库，都是需要用表来存放数据的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] table_name(</span><br><span class="line">    column_list</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>举例:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_table(</span><br><span class="line">    table_id <span class="built_in">INT</span> AUTO_INCREMENT, #设置一个列，取名叫table_id，数据类型为<span class="built_in">INT</span>，并且是自动增长的</span><br><span class="line">    title <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>, #创建title列，数据类型为<span class="built_in">VARCHAR</span>类型，最长<span class="number">10</span>，并且不为空</span><br><span class="line">    create_date <span class="built_in">DATE</span>, #创建create_date列，数据类型为<span class="built_in">DATE</span>，可以为空</span><br><span class="line">    usercount <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, #创建usercount列，设置默认值为<span class="number">0</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (table_id), #设置主键为table_id</span><br><span class="line">    <span class="keyword">UNIQUE</span> (title), #设置title必须唯一</span><br><span class="line">    <span class="keyword">CHECK</span> (usercount&gt;<span class="number">-1</span>), #设置usercount列的数据不能是负数</span><br><span class="line">    FOREGIN <span class="keyword">KEY</span> (another_id) <span class="keyword">REFERENCES</span> anoter_table(another_id), #设置another_id列，并且与anoter_table表的another_id关联</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>解释:</p><blockquote><p>主键的作用：确定了数据的唯一性，便于其它表的关联，配合索引提升数据查找性能<br>SQL约束：<code>NOT NULL</code>, <code>UNIQUE</code>, <code>PRIMARY KEY</code>, <code>FOREIGN KEY</code>, <code>DEFAULT</code>, <code>CHECK</code></p></blockquote><h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><p>基本语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>有时候我们选取的数据有重复的情况，但是我们只想让它只显示一次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1 <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><h3 id="WHERE语句"><a href="#WHERE语句" class="headerlink" title="WHERE语句"></a>WHERE语句</h3><p>基本语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> cloumn_name=<span class="string">'condition'</span>;</span><br></pre></td></tr></table></figure><h3 id="INSERT语句"><a href="#INSERT语句" class="headerlink" title="INSERT语句"></a>INSERT语句</h3><p>基本语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 指定列名插入</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2) <span class="keyword">VALUES</span> (value1, value2);</span><br><span class="line"></span><br><span class="line"># 指定列名插入多条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name(column1, column2) <span class="keyword">VALUES</span> (value1, value2), (value11, value22);</span><br><span class="line"></span><br><span class="line"># 如果插入全部数据，可以不指定列名，注意自动增加的字段可以不写</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2);</span><br><span class="line"></span><br><span class="line"># 不指定列名插入多条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name <span class="keyword">VALUES</span> (value1, value2), (value11, value22);</span><br></pre></td></tr></table></figure><h3 id="UPDATE语句"><a href="#UPDATE语句" class="headerlink" title="UPDATE语句"></a>UPDATE语句</h3><p>基本语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1 = new_value1, column2 = new_value2 <span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>注意: SET后面是需要更新的列，指定多列，中间用英文的逗号分开，WHERE语句是可选的，如果没有这个语句，默认更新所有的行的数据。</p><h3 id="DELETE语句"><a href="#DELETE语句" class="headerlink" title="DELETE语句"></a>DELETE语句</h3><p>基本语法:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> condition;</span><br></pre></td></tr></table></figure><p>注意: 如果没有WHERE子句进行限制，默认删除所有的数据。</p><h3 id="COUNT函数"><a href="#COUNT函数" class="headerlink" title="COUNT函数"></a>COUNT函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SELECT</span> column1, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column2=condition;</span><br></pre></td></tr></table></figure><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1=condition;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-DESC"><a href="#ORDER-BY-DESC" class="headerlink" title="ORDER BY(DESC)"></a>ORDER BY(DESC)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column1;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">ORDER</span> <span class="keyword">BY</span> column1 <span class="keyword">DESC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> column1 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2;</span><br></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column1 <span class="keyword">LIKE</span> <span class="string">'auto%'</span>;</span><br></pre></td></tr></table></figure><p>其中<code>%</code>可以匹配多个多个，<code>_</code>只能匹配单个字符</p><h3 id="AVG函数"><a href="#AVG函数" class="headerlink" title="AVG函数"></a>AVG函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">column</span>) <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SELECT</span> column1, column2 <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> columnx &gt; (<span class="keyword">SELECT</span> <span class="keyword">AVG</span>(columny) <span class="keyword">FROM</span> table_name);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2017/04/26/hello-world/"/>
      <url>/2017/04/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><p>222698602</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
