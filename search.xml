<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Linux-环境变量</title>
      <link href="/2018/07/13/Linux/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2018/07/13/Linux/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以修改/etc/profile下面，这个是针对全局用户的，如果想针对某个用户修改，比如root用户，可以使用/root/.bashrc文件</p><h2 id="配置格式"><a href="#配置格式" class="headerlink" title="配置格式"></a>配置格式</h2><p>文件里面的配置格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/path/to/java</span><br><span class="line">export PATH=/path/to/add:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>数据库-SQL语句</title>
      <link href="/2018/07/13/Database/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/07/13/Database/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p>本文主要记录了SQL语句的使用。</p><a id="more"></a><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组的原则是先按照条件选取数据，然后按照分组统计数据。</p><p>比如现在有下面的一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">areaid client tx</span><br><span class="line">1   a   100</span><br><span class="line">1   a   200</span><br><span class="line">1   b   150</span><br><span class="line">2   c   200</span><br></pre></td></tr></table></figure><p>现在通过下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT areaid, count(distinct client) as count, sum(tx) as tx GROUP BY areaid</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   2   450</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>注意上面对client使用的distinct去重，如果不用得到的结果是，整体过程是先选择areaid，并且按照areaid分组，然后统计每个组下面的去重后的client的数量，同时统计每个组下面的tx的和，注意没有根据任何去重。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   3   450</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>如果使用下面的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select areaid, count(client), sum(tx) from test group by areaid, client;</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   2   300</span><br><span class="line">1   1   150</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>也就是先按照了areaid分组，在按照了client进行分组</p>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-定时任务</title>
      <link href="/2018/07/12/Linux/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/07/12/Linux/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>本文主要记录了Linux的定时任务，比如crontab。</p><a id="more"></a><h2 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h2><p>我们可以通过crontab命令来配置我们的定时任务，比如每小时，每天，每隔多少分钟(小时，天，周)，每周的第几天等等，有点类似Jenkins上配置定时任务的功能，语法也类似。</p><h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h3><p>首先通过命令<code>crontab -e</code>会进入crontab的编辑界面，里面的操作就类似于使用vim编辑文件一样，只是需要遵守格式即可，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 * * * * task #没小时的10分钟的时候执行task</span><br><span class="line">30 10 * * * task #每天的10:30分执行task</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontal -l #查看crontab里面配置的定时任务</span><br></pre></td></tr></table></figure><h3 id="任务跟踪"><a href="#任务跟踪" class="headerlink" title="任务跟踪"></a>任务跟踪</h3><p>可以通过下面的命令查看crontab的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 /var/spool/mail/root #这个会把crontab的运行日志记录在里面，当然这里使用tail命令只查看了最后的100行</span><br><span class="line"></span><br><span class="line">tail -f /var/log/cron #这个是查看crontab执行了哪些任务的跟踪</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-文件处理</title>
      <link href="/2018/07/12/Linux/Linux-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/12/Linux/Linux-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文主要记录了Linux的文件处理，比如压缩解压等。</p><a id="more"></a><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r test.zip test #压缩test，压缩文件名为test.zip，另外压缩文件解压后就和test完全一致，没有里面在嵌套一层的说法</span><br><span class="line">zip -t test.zip #在不解压的情况下查看压缩文件的内容</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大数据-入门</title>
      <link href="/2018/07/12/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/12/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>由于对Python比较熟悉，公司要使用Python进行大数据处理，本文记录了处理大数据过程的内容，内容比较杂乱，后期会单独整理成独立的文章。</p><a id="more"></a><h2 id="名词与理论"><a href="#名词与理论" class="headerlink" title="名词与理论"></a>名词与理论</h2><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ol><li>RDD: Resilient Distributed Dataset, 弹性式分布数据集</li><li>HDFS: Hadoop Distributed File System</li><li>JDBC: Java DataBase Connectivity, java数据库连接</li></ol><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>数据库事务：就是针对一系列的sql语句要么都执行成功，要么都不执行，比如银行转账，需要执行两条sql语句，一条减少转出人的账户，一条增加转入人的账户，这两条必须同时执行否则就会出错，cursor是把sql的操作放到缓存里面，如果不执行commit，是不会提交事务的，如果任意一个失败，可以使用rollback进行事物回滚，大家都不执行。</p><p>另外，记住cursor是操作的缓存，比如select语句以后，选出的内容都存放在缓冲里面，如果使用fetchall，那么取得全部数据，这时候在用fetch等一系列函数将获取不到任何数据了，因为fetchall已经把缓存里面的数据全部拿走了，当然如果使用两次的fetchone，他们获得的是两次不同的数据，也就是按次序获取如果中间再次使用了select语句，那么缓存内容被更新，当然这里不单单指select语句了，执行了任何语句，缓冲内容都会被更心，比如开始执行了select语句，马上执行insert语句，那么通过fetch函数是获取不到任何内容的cursor不论关闭还是打开，只要connection没有关闭，那么cursor都可以获取到本轮修改的内容，而不是原始数据库的内容了，如果执行了commit，此时数据库才会被修改，也就是说，没有必要关闭cursor，直接关闭connection即可。同理，如果没有commit，使用了rollback，那么重新select的数据就和数据库一致了。</p><p>其实也有个问题就是，如果有改动的操作，一定要commit后在使用select去查。另外如果一条insert，然后马上使用delete删除与此insert有相同的条件，那么数据库里面满足条件的和刚刚insert满足条件的都会被删除，当然你必须执行commit后才能提交到数据库中。</p><h2 id="几幅图片"><a href="#几幅图片" class="headerlink" title="几幅图片"></a>几幅图片</h2><h3 id="yarn相关"><a href="#yarn相关" class="headerlink" title="yarn相关"></a>yarn相关</h3><p><img src="yarn.png" alt="yarn"></p><h3 id="spark相关"><a href="#spark相关" class="headerlink" title="spark相关"></a>spark相关</h3><p><img src="spark1.png" alt="spark1"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Python-Spark"><a href="#Python-Spark" class="headerlink" title="Python+Spark"></a>Python+Spark</h3><ol><li><a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">http://spark.apache.org/downloads.html</a> 官网下载好压缩包，直接解压后，配置好SPARK_HOME到根目录下，然后把%SPARK_HOME%\bin加入到Path环境目录下，就可以通过pyspark命令启动交互式shell了。</li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>此时不应有JAVA….之类的错误</li></ol><blockquote><p>请检查JAVA_HOME JRE_HOME的环境变量是否包含了(x86)这种格式，spark不识别括号，所以需要重新配置这个环境变量，主要不要有括号，比如安装到64位的安装目录下，获取重新安装JAVA到其它文件夹</p></blockquote><ol start="2"><li>如果启动过程中发现报错的信息有关于hadoop相关的</li></ol><blockquote><p>主要是没有hadoop相关的配置，由于在前面选择下载spark的时候，选择的是Pre-builtfor Apache-Hadoop2.7 and later，所以我们需要去下载Hadoop2.7或以后的版本，下载好后，同样的需要配置HADOOP_HOME，并且把HADOOP_HOME\bin加入到环境变量中，重新再次启动，关于hadoop的错误提示应该就没有了。</p></blockquote><blockquote><blockquote><p>注意hadhoop spark的环境变量的配置路径里面不能有空格，括号，比如Programe file这里有空格，可以是使用PROGRA~1代替</p></blockquote></blockquote><blockquote><blockquote><p>如果提示找不到winutils， 可以到 <a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">https://github.com/steveloughran/winutils</a> 下载对应的winutils放到hadoop的bin目录下，重新执行即可</p></blockquote></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>环境都都配置好后，通过下面的命令检查环境是否正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell</span><br></pre></td></tr></table></figure><p>可以打开spark-shell.cmd查看里面的内容，其中<code>%~dp0</code>表示当前文件所在目录, <code>%*</code>表示传递过来的参数</p><h3 id="windows配置IP对应域名"><a href="#windows配置IP对应域名" class="headerlink" title="windows配置IP对应域名"></a>windows配置IP对应域名</h3><p>类似Linux下/etc/host文件，Windows是在C:\Windows\System32\drivers\etc这个目录下，配置格式大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.20.115 ism</span><br></pre></td></tr></table></figure><h2 id="Spark概念"><a href="#Spark概念" class="headerlink" title="Spark概念"></a>Spark概念</h2><p>Spark里面有一些概念在下面进行记录。</p><h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p>这个是action里面的一个函数， 里面的withReplacement是指放回抽样(True)和不放回抽样(False)，比如有5个不同颜色的小球，每次抽取两个，放回抽样，类似于先抽取一个，比如抽到白色，然后放回，在抽取一个这次有可能还是抽到白球，而不放回抽样，就是先抽取一个，比如抽取到白球，这个球不会放回，里面只有4个球，在抽取一个，也就是两次的结果是肯定不会一样的</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In general, configuration values explicitly set on a SparkConf take the highest precedence, then flags passed to spark-submit, then values in the defaults file. If you are ever unclear where configuration options are coming from, you can print out fine-grained debugging information by running spark-submit with the --verbose option</span><br></pre></td></tr></table></figure><h2 id="Pyspark"><a href="#Pyspark" class="headerlink" title="Pyspark"></a>Pyspark</h2><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>下面的是先记录下来，以后作详细的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).load()</span><br><span class="line"></span><br><span class="line">a.write.format(&quot;jdbc&quot;).mode(&quot;append&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).save()</span><br><span class="line"></span><br><span class="line">lines = sc.textFile(&quot;file:/C:/Users/sk-leilin/Desktop/test.txt&quot;)</span><br><span class="line"></span><br><span class="line">db.collection.find(query, projection);</span><br><span class="line">db.collection.find().pretty();</span><br><span class="line">db.collection.findOne();</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line">lines = sc.textFile(&quot;file:/C:/Users/sk-leilin/Desktop/test.txt&quot;)</span><br><span class="line">parts = line.map(lambda x: x.split(&apos;,&apos;))</span><br><span class="line">data = spark.createDataFrame(parts, [&quot;language&quot;, &quot;salary&quot;])</span><br><span class="line">data.write.format(&quot;jdbc&quot;).mode(&quot;append&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).save()</span><br></pre></td></tr></table></figure><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /tmp #查看</span><br><span class="line">hdfs dfs -put test.txt2 /tmp/ #上传本地test.txt2到hdfs的tmp目录</span><br></pre></td></tr></table></figure><p>动态分区问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.dynamic.partition=true;</span><br><span class="line">set hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use db;</span><br><span class="line">show tables;</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">show create table test_table; #查看hive存储位置，里面有一个LOCATION字段</span><br><span class="line">desc test_table; #查看表结构，(desc 是 description)</span><br><span class="line"></span><br><span class="line">select * from tb limit 10;</span><br></pre></td></tr></table></figure><h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">conda list #列出当前环境的安装的库</span><br><span class="line">conda info --env 查看已有的环境 #或者使用conda env list</span><br><span class="line">conda create --name testpy python=3.4 创建一个新的基于3.4的环境</span><br><span class="line">conda install numpy</span><br><span class="line">conda list -n testpy #查看testpy下的安装库</span><br><span class="line">conda install -n testpy numpy #在testpy下安装numpy</span><br><span class="line">conda remove -n testpy numbpy #移除testpy下的numpy</span><br><span class="line">conda update numpy/python/conda/anaconda #由于conda把所有的都当成的包的方式管理，这里也可以把python当成包来管理</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ #添加Anaconda的TUNA镜像</span><br><span class="line">conda config --set show_channel_urls yes # 设置搜索时显示通道地址</span><br><span class="line">conda remove -n testpy --all #移除testpy环境，默认是在anaconda的envs文件夹下面</span><br><span class="line">conda config --show #查看配置</span><br><span class="line">conda create -n testpy --clone root #从root直接克隆一个环境叫testpy</span><br><span class="line">source activate testpy #激活testpy环境</span><br><span class="line">source deactivate #退出</span><br></pre></td></tr></table></figure><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1530842592838_0023 #查看指定application的log</span><br></pre></td></tr></table></figure><h3 id="pyspark"><a href="#pyspark" class="headerlink" title="pyspark"></a>pyspark</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master yarn --num-executors 2 --executor-memory 2g</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps #查看jvm进程</span><br></pre></td></tr></table></figure><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><p>下面的是先记录下来，以后作详细的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --jars ./postgresql-42.2.2.jar --executor-memory 2G --num-executors 4 --master yarn --deploy-mode client --conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=/opt/anaconda3/bin/python ./pgsql.py</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8088端口: 可以查看运行的app</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>虽然目前很多概念性的理论东西不是很熟悉，但是先熟悉下环境的配置。</p><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3>]]></content>
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tool-docker</title>
      <link href="/2018/07/04/Tools/Tool-docker/"/>
      <url>/2018/07/04/Tools/Tool-docker/</url>
      <content type="html"><![CDATA[<p>本文主要记录了docker的基本使用。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CentOS下安装"><a href="#CentOS下安装" class="headerlink" title="CentOS下安装"></a>CentOS下安装</h3><h4 id="直接通过yum的方式安装"><a href="#直接通过yum的方式安装" class="headerlink" title="直接通过yum的方式安装"></a>直接通过yum的方式安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update #确保是最新的yum源</span><br><span class="line">yum -y install docker-io #这里-y参数是在yum里面会有各种提示y/d/n等你输入，如果这里-y参数提供了，那么默认输入y</span><br><span class="line">service docker start #启动docker服务</span><br><span class="line"></span><br><span class="line">docker run hello-world #可以测试一个helloworld程序，这个默认是不存在的，会在docker仓库拉取一次</span><br></pre></td></tr></table></figure><blockquote><p>如果CentOS7里面使用<code>service</code>命令启动docker报错，可以使用<code>systemctl start docker</code>的方式查看是否可以启动。</p></blockquote><blockquote><p>如果CentOS7里面启动docker报错，可以试着重新安装<code>yum install docker-engine</code>这个即可，安装之前卸载掉前面安装的内容<code>yum remove docker;yum remove docker-selinux</code>。</p></blockquote><h5 id="服务相关几个命令-以docker服务为例-："><a href="#服务相关几个命令-以docker服务为例-：" class="headerlink" title="服务相关几个命令(以docker服务为例)："></a>服务相关几个命令(以docker服务为例)：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">启动docker：systemctl start docker</span><br><span class="line">停止docker：systemctl stop docker</span><br><span class="line">重启docker：systemctl restart docker</span><br><span class="line">查看docker状态：systemctl status docker</span><br><span class="line">开机启动：systemctl enable docker</span><br><span class="line"></span><br><span class="line">[root@localhost system]# systemctl list-unit-files | grep docker</span><br><span class="line">docker-cleanup.service                        disabled</span><br><span class="line">docker-storage-setup.service                  disabled</span><br><span class="line">docker.service                                disabled</span><br><span class="line">docker-cleanup.timer                          disabled</span><br><span class="line">[root@localhost system]# </span><br><span class="line">[root@localhost system]# </span><br><span class="line">[root@localhost system]# systemctl cat docker.service #这里可以查看服务配置文件位置</span><br></pre></td></tr></table></figure><h4 id="镜像源的配置"><a href="#镜像源的配置" class="headerlink" title="镜像源的配置"></a>镜像源的配置</h4><p>由于国外镜像不能访问或者很慢，可以编辑<code>/etc/docker/daemon.json</code>这个文件，配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然也可以配置&quot;insecure-registries&quot;:[&quot;10.10.30.240:5000&quot;]为自己的私人仓库地址</span><br></pre></td></tr></table></figure><blockquote><p>注意如果在CentOS7里面，配置这个不生效的情况，可以查看<code>/etc/sysconfig/docker</code>这个文件，里面让<code>Do not add registries in this file anymore. Use /etc/containers/registries.conf</code>这样做，我们查看<code>/etc/containers/registries.conf</code>这个文件，可以看到<code>registries.search</code>这个字段，我们增加我们自己的仓库即可。比如增加阿里云的仓库<code>r6w9c7qa.mirror.aliyuncs.com/library</code>。</p></blockquote><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>有时候内网无法访问外网，通过设置http代理的方式是不能解决docker pull镜像的，所以可以在一台可以访问外网的机器上搭建自己的私有仓库，然后内网去拉去这里面的镜像即可。</p><h3 id="CentOS7的搭建"><a href="#CentOS7的搭建" class="headerlink" title="CentOS7的搭建"></a>CentOS7的搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br><span class="line">docker run -d -p 5000:5000 -v /opt/registry:/var/lib/registry --restart=always --name registry registry</span><br><span class="line">docker ps #可以查看刚刚启动的registry，通过范文`http://IP:5000/v2/_catalog`查看仓库已有的镜像，如果是新建的，一般是空的</span><br><span class="line">docker pull busybox #拉取一个busybox到本地，这里使用busybox进行测试，因为这个很小</span><br><span class="line">docker images #查看拉取得镜像</span><br><span class="line">docker tag busybox registry:5000/busybox #给自己的镜像取个名字，加入tag，这里只是多了一个镜像，busybox这个原始镜像仍然还在</span><br></pre></td></tr></table></figure><blockquote><p>注意上面说的tag步骤，说法不是很准确，如果给一个镜像修改自己的tag，完整的是<code>docker tag busybox new_name:new_tag</code>，其中<code>new_name:new_tag</code>里面的new_name是取得新的名字，比如上例中的<code>registry:5000/busybox</code>，这只是一个名字，加入的tag是默认的latest。</p></blockquote><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Jenkins:~# cat /etc/docker/daemon.json </span><br><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;registry:5000&quot;] &#125;</span><br></pre></td></tr></table></figure><p>查看仓库的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://registry:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p>内网机器拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker #查看docker服务的配置文件，一般是/usr/lib/systemd/system/docker.service，在这个文件的ExecStart字段里面增加--add-registry=registry:5000 --insecure-registry=registry:5000</span><br><span class="line"></span><br><span class="line">systemctl start docker #启动docker服务</span><br><span class="line"></span><br><span class="line">docker pull busybox #拉取本地镜像，这个速度很快的</span><br></pre></td></tr></table></figure><blockquote><p>注意了， registry:5000上面的配置中registry都必须是仓库的IP地址，包括<code>docker tag busybox registry:5000/busybox</code>这句，里面也是固定的，否则通过<code>docker push</code>是push到了docker.io里面去的。</p></blockquote><blockquote><p>docker run里面的参数说明：-d -p -v –restart –name</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker --help #可以查看docker命令的帮助</span><br><span class="line">docker stats --help #可以查看stats子命令的帮助</span><br><span class="line"></span><br><span class="line">docker info #查看docker环境的配置信息</span><br></pre></td></tr></table></figure><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi imagename #如果镜像容器已经运行，需要先删除容器</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-网络配置</title>
      <link href="/2018/07/04/Linux/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/07/04/Linux/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>主要记录了Linux网络相关的配置，比如IP地址，防火墙等。</p><a id="more"></a><h2 id="IP配置"><a href="#IP配置" class="headerlink" title="IP配置"></a>IP配置</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先编辑文件：vim etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">device=eth0</span><br><span class="line">bootproto=dhcp #如果需要手动配置IP地址，这里配置为none</span><br><span class="line">onboot=yes #是否随系统启动</span><br><span class="line">hwaddr=09:0a #mac地址</span><br><span class="line">IPADDR=10.0.1.27  #IP地址</span><br><span class="line">NETMASK=255.255.255.0  </span><br><span class="line">GATEWAY=10.0.1.1</span><br><span class="line">最后重启服务：service network restart</span><br></pre></td></tr></table></figure><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="CentOS-1"><a href="#CentOS-1" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑文件：vim etc/sysconfig/network-scripts/route-eth0</span><br><span class="line">格式为：10.0.0.0/8 via 192.168.53.1，其中192.168.53.1这个是网关</span><br></pre></td></tr></table></figure><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><h3 id="CentOS-2"><a href="#CentOS-2" class="headerlink" title="CentOS"></a>CentOS</h3><p>如果遇到root用户不能登陆的情况，修改<code>/etc/ssh/sshd_config</code>文件，取消<code>PermitRootLogin</code>这个参数的注释。</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
