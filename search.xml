<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>大数据-hive基本操作</title>
      <link href="/2018/07/16/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-hive%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要记录了hive的一些基本操作。</p><a id="more"></a><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>进入命令行一般使用<code>hive</code>可以直接进入交互shell。</p><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show databases; #查看有哪些数据库</span><br><span class="line"></span><br><span class="line">use db</span><br><span class="line"></span><br><span class="line">show tables; #查看有哪些表</span><br><span class="line"></span><br><span class="line">desc table; #查看table表的结构</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-常用命令合集</title>
      <link href="/2018/07/16/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2018/07/16/Linux/Linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-Anaconda管理</title>
      <link href="/2018/07/16/Python/Python-Anaconda%E7%AE%A1%E7%90%86/"/>
      <url>/2018/07/16/Python/Python-Anaconda%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-xml操作</title>
      <link href="/2018/07/16/Python/Python-xml%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Python/Python-xml%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-ini文件操作</title>
      <link href="/2018/07/16/Python/Python-ini%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Python/Python-ini%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-py4j模块</title>
      <link href="/2018/07/16/Python/Python-py4j%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/07/16/Python/Python-py4j%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[<p>py4j是python和java交互的一个模块。</p>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-文件操作</title>
      <link href="/2018/07/16/Python/Python-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Python/Python-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>English-句段收藏</title>
      <link href="/2018/07/16/English/English-%E5%8F%A5%E6%AE%B5%E6%94%B6%E8%97%8F/"/>
      <url>/2018/07/16/English/English-%E5%8F%A5%E6%AE%B5%E6%94%B6%E8%97%8F/</url>
      <content type="html"><![CDATA[<h3 id="S1"><a href="#S1" class="headerlink" title="S1"></a>S1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This module provides various time-related functions.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Although this module is always available, not all functions are available on all platforms.</span><br></pre></td></tr></table></figure><p>句子中although是一个从属连词，引导状语从句，翻译尽管但是的语句的时候，不能和but连用，因为but是并列连词(FANBOYS)，并列句前后的句子必须具有相同的等级，所以although和but不能连用。同理，because和so也不能连用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An explanation of some terminology(术语) and conventions(惯例) is in order.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapping is A container object that supports arbitrary(任意的) key lookups(查找) and implements the methonds specified in the Mapping or MutableMapping. (mutable易变的, immutable不可变的)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tool-github博客搭建</title>
      <link href="/2018/07/16/Tools/Tool-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/07/16/Tools/Tool-github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tool-Git操作</title>
      <link href="/2018/07/16/Tools/Tool-Git%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Tools/Tool-Git%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-日志模块</title>
      <link href="/2018/07/16/Python/Python-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
      <url>/2018/07/16/Python/Python-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-Collection</title>
      <link href="/2018/07/16/Python/Python-Collection/"/>
      <url>/2018/07/16/Python/Python-Collection/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-操作PostgreSQL</title>
      <link href="/2018/07/16/Python/Python-%E6%93%8D%E4%BD%9CPostgreSQL/"/>
      <url>/2018/07/16/Python/Python-%E6%93%8D%E4%BD%9CPostgreSQL/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-枚举</title>
      <link href="/2018/07/16/Python/Python-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2018/07/16/Python/Python-%E6%9E%9A%E4%B8%BE/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-json库</title>
      <link href="/2018/07/16/Python/Python-json%E5%BA%93/"/>
      <url>/2018/07/16/Python/Python-json%E5%BA%93/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-requests</title>
      <link href="/2018/07/16/Python/Python-requests/"/>
      <url>/2018/07/16/Python/Python-requests/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-随机数</title>
      <link href="/2018/07/16/Python/Python-%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
      <url>/2018/07/16/Python/Python-%E9%9A%8F%E6%9C%BA%E6%95%B0/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-字符串操作</title>
      <link href="/2018/07/16/Python/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"/>
      <url>/2018/07/16/Python/Python-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p>本文主要记录了python对字符串的相关操作。</p><a id="more"></a><h2 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h2><h3 id="使用format函数"><a href="#使用format函数" class="headerlink" title="使用format函数"></a>使用format函数</h3><p>比如有一个字符串，使用百分号进行格式化的时候。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;My name is %s, %d years old.&quot; % (&quot;Liburro&quot;, 2)</span><br></pre></td></tr></table></figure><p>我们可以使用format函数进行格式化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;My name is &#123;name&#125;, &#123;age&#125; years old.&quot;.format(name=&quot;Liburro&quot;, age=2)</span><br></pre></td></tr></table></figure><p>上面的方式，可以清晰的知道具体格式化的值是多少，对应的是哪一个，如果使用<code>%</code>的方式，需要格式化的内容太多，很容易混淆，使用<code>format</code>方式则可以很容易看出哪里错误，而且不用指定数据类型。</p><blockquote><p>另外， 使用<code>format</code>函数，字符串里面可以有同名的替换，<code>format</code>函数里面只需要指定一次，则都被替换为对应的值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#123;a&#125;, &#123;b&#125;, &#123;a&#125;&quot;.format(a=1, b=2) #字符串里面的两个a都会格式化为1</span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>split函数把字符串按照指定的分隔符分开，返回分割后的内容，并且是一个列表。split接收三个参数，第一个是需要被分割的字符串，第二个是分隔符，默认是<code>None</code>，第三个是分割的最大次数，默认是-1，就是全部分割。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;a b c  d  e  f&apos; #注意，c后面的字符都是两个空格了</span><br><span class="line">b = a.split() #默认按照空格进行分割，并且多个空格都被忽略，b就是返回值[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;]</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果使用<code>b = a.split(&quot; &quot;)</code>显示方式指明了按照空格进行分割，那么返回的内容里面只会是按照一个空格进行分割后的值，也就是返回了<code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;&#39;, &#39;d&#39;, &#39;&#39;, &#39;e&#39;, &#39;&#39;, &#39;f&#39;]</code></p></blockquote><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join函数可以把一个容器根据指定的连接符连接起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line">&apos;,&apos;.join(a) # 返回a,b,c</span><br><span class="line"></span><br><span class="line">a = [&apos;a&apos;]</span><br><span class="line">&apos;,&apos;.join(a) # 返回a，也就是说只有一个元素的情况下，直接返回这个字符串，没有附加连接符</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-基础进阶</title>
      <link href="/2018/07/16/Python/Python-%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/"/>
      <url>/2018/07/16/Python/Python-%E5%9F%BA%E7%A1%80%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<p>本文记录了python的一些基础操作以及基础进阶的内容。包括大多数内建函数，列表，字典等的操作，也包含了sys等模块的一些基础特性。</p><a id="more"></a><h2 id="列表的几个操作"><a href="#列表的几个操作" class="headerlink" title="列表的几个操作"></a>列表的几个操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = list()</span><br><span class="line">a.append(1) # 增加一个元素，[1]</span><br><span class="line">a.append([2,3]) #append是添加一个元素，而不管元素内容， 其中[2,3]作为a的第二个元素 [1,[2,3]]</span><br><span class="line">a.extend([2,3]) #extend直接作用于a，并且只能接受列表参数，[1,[2,3],2,3]</span><br><span class="line">a + [1,2,3] #这个返回值是[1,[2,3],2,3,1,2,3]但是a本身仍然没有变化</span><br></pre></td></tr></table></figure><h2 id="len函数的替代"><a href="#len函数的替代" class="headerlink" title="len函数的替代"></a>len函数的替代</h2><p>先看下面的代码，假设temp是一个列表，或者一个字符串，或者任意的可求长度的类型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum(1 for _ in temp)</span><br><span class="line"></span><br><span class="line">len(temp)</span><br></pre></td></tr></table></figure><p>上面的两组操作都可以获取temp的长度。</p><blockquote><p>注意<code>_</code>在python中也是一个有效的变量名。另外在python交互式窗口里面，<code>_</code>代表上一次执行的结果。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">In [25]: a = 1</span><br><span class="line"></span><br><span class="line">In [26]: a</span><br><span class="line">Out[26]: 1</span><br><span class="line"></span><br><span class="line">In [27]: _</span><br><span class="line">Out[27]: 1</span><br><span class="line"></span><br><span class="line">In [28]: b = 2</span><br><span class="line"></span><br><span class="line">In [29]: print b</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">In [30]: _</span><br><span class="line">Out[30]: 1</span><br><span class="line"></span><br><span class="line">In [31]:</span><br></pre></td></tr></table></figure><h2 id="and等运算符"><a href="#and等运算符" class="headerlink" title="and等运算符"></a>and等运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 and 0 #返回0</span><br><span class="line">2 or 1 #返回2</span><br></pre></td></tr></table></figure><h2 id="ifelse"><a href="#ifelse" class="headerlink" title="ifelse"></a>ifelse</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = 1 if 1 == 1 else 0</span><br></pre></td></tr></table></figure><h2 id="空值的判断"><a href="#空值的判断" class="headerlink" title="空值的判断"></a>空值的判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = None #python里面[],&apos;&apos;,0,False等都是非真值</span><br><span class="line">if a:</span><br><span class="line">    do_something()</span><br><span class="line">else:</span><br><span class="line">    do_other_something()</span><br></pre></td></tr></table></figure><h2 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h2><h2 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h2><h2 id="解包-和-的操作"><a href="#解包-和-的操作" class="headerlink" title="解包(*和**的操作)"></a>解包(<code>*</code>和<code>**</code>的操作)</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h3 id="yield语句"><a href="#yield语句" class="headerlink" title="yield语句"></a>yield语句</h3><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def test_yield(x):</span><br><span class="line">    for i in range(x):</span><br><span class="line">        a = yield i</span><br><span class="line">        print(a)</span><br><span class="line"></span><br><span class="line">a = test_yield(5)</span><br><span class="line">print(next(a))</span><br><span class="line">print(next(a))</span><br><span class="line"></span><br><span class="line">print(next(a)) #0</span><br><span class="line">print(next(a)) #None 1</span><br><span class="line">print(a.send(100)) #100 2</span><br><span class="line">print(next(a)) #None 3</span><br><span class="line"></span><br><span class="line">0 #首先执行到yield，把后面的表达式i返回了，也就是第一次进入，为0</span><br><span class="line">None #第二次调用next的时候，接着上一次暂停的地方继续执行，打印a，默认为None</span><br><span class="line">1 #然后又执行到了yield的地方，返回了第二次的结果1</span><br><span class="line">100 #然后send了100，a获取到了100，并且执行到了下一次的yield，下一步马上打印2</span><br><span class="line">2 #接上一步</span><br><span class="line">None #最后一个next，a没有值，默认None</span><br><span class="line">3 #执行到了yield地方，打印3</span><br></pre></td></tr></table></figure><h4 id="yield-from子句"><a href="#yield-from子句" class="headerlink" title="yield from子句"></a>yield from子句</h4><h4 id="throw函数"><a href="#throw函数" class="headerlink" title="throw函数"></a>throw函数</h4><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="多重装饰器"><a href="#多重装饰器" class="headerlink" title="多重装饰器"></a>多重装饰器</h3><h2 id="类相关"><a href="#类相关" class="headerlink" title="类相关"></a>类相关</h2><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><h3 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h3><h3 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod"></a>staticmethod</h3><h3 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="特殊成员的继承"><a href="#特殊成员的继承" class="headerlink" title="特殊成员的继承"></a>特殊成员的继承</h4><p>包括类变量， class和static method的继承</p><h2 id="import的理解"><a href="#import的理解" class="headerlink" title="import的理解"></a>import的理解</h2><h2 id="特殊的函数和变量"><a href="#特殊的函数和变量" class="headerlink" title="特殊的函数和变量"></a>特殊的函数和变量</h2><h3 id="all"><a href="#all" class="headerlink" title="__all__"></a><code>__all__</code></h3><h3 id="file"><a href="#file" class="headerlink" title="__file__"></a><code>__file__</code></h3><h3 id="name"><a href="#name" class="headerlink" title="__name__"></a><code>__name__</code></h3><h2 id="sys模块基础功能"><a href="#sys模块基础功能" class="headerlink" title="sys模块基础功能"></a>sys模块基础功能</h2><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>当使用下面的方式执行py脚本的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python example.py 1 abc</span><br></pre></td></tr></table></figure><p>sys模块提供了一个变量<code>sys.argv</code>可以获取到命令行参数的值，其中<code>sys.argv[0]</code>是这个脚本的名字， <code>sys.argv[1]</code>是1，<code>sys.argv[2]</code>是abc。</p><blockquote><p>其中<code>sys.argv[0]</code>这个的值是根据<code>python example.py 1 abc</code> 中py文件获取的，也就是说，如果你跟的是路径，那么<code>sys.argv[0]</code>也获取到路径，简单理解为python是一个命令，后面的都是参数，传递什么，<code>sys.argv</code>就会原封不动的获取到什么。</p></blockquote><h3 id="python3的坑"><a href="#python3的坑" class="headerlink" title="python3的坑"></a>python3的坑</h3><h4 id="map对象"><a href="#map对象" class="headerlink" title="map对象"></a>map对象</h4><p>在python2里面map返回的是一个列表类型的，但是在python3里面返回的是一个迭代器，那么这里就有影响了。比如python2里面可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = map(str, a) #这里b是一个列表</span><br><span class="line">for i in b:</span><br><span class="line">    print i</span><br><span class="line">for i in b:</span><br><span class="line">    print i #上面不会影响这里的结果，和上面打印的内容一致</span><br></pre></td></tr></table></figure><p>我们来看python3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = map(str, a) #这里b是一个迭代器</span><br><span class="line">for i in b:</span><br><span class="line">    print(i) #这里和上面一样，123都会打印</span><br><span class="line">for i in b:</span><br><span class="line">    print(i) #注意了，这里不会有任何输出</span><br></pre></td></tr></table></figure><p>为什么呢，因为第一个for已经把迭代器的元素遍历完了，后面继续遍历就已经没有内容了，同样需要注意，所有可以对这种迭代对象进行操作的函数也会产生这样的效果。比如python3里面:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3]</span><br><span class="line">b = map(str, a) #这里b是一个迭代器</span><br><span class="line">c = &apos; &apos;.join(b) #把b里面的元素用空格连接，返回一个字符串</span><br><span class="line">for i in b:</span><br><span class="line">    print(i) #注意了，这里不会有任何输出，因为join函数已经把b遍历完了。</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Python-时间处理</title>
      <link href="/2018/07/16/Python/Python-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/16/Python/Python-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>Python时间相关的有好几个模块，提供了很丰富的API，一般都能满足我们的要求。</p><a id="more"></a><h2 id="时间相关概念"><a href="#时间相关概念" class="headerlink" title="时间相关概念"></a>时间相关概念</h2><h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>UTC是世界统一时间，中国是UTC+8。</p><h3 id="DST"><a href="#DST" class="headerlink" title="DST"></a>DST</h3><p>DST是夏令时，大概意思是日照时间提前，会人为的把时间调前比如1个小时。</p><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p><a href="https://docs.python.org/3/library/time.html" target="_blank" rel="noopener">https://docs.python.org/3/library/time.html</a></p><p>time模块直接使用的是C的库，所以根据平台的特性会有不同的效果。</p><h3 id="struct-time"><a href="#struct-time" class="headerlink" title="struct_time"></a><code>struct_time</code></h3><p>有6个常用的函数会使用到这个namedtuple，其中gmtime,localtime,strptime会返回这个对象，而asctime,mktime,strftime会接收这个对象。</p><p>其中gmtime,localtime接收time()数据返回<code>struct_time</code>格式，mktime接受<code>strcut_time</code>数据，返回time()格式。</p><p><img src="struct_time.png" alt="struct_time"></p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>time函数不接受参数，返回本地时间的相对于世纪元的秒数，是一个float类型。</p><h3 id="mktime"><a href="#mktime" class="headerlink" title="mktime"></a>mktime</h3><p>mktime接收一个<code>strcut_time</code>格式，返回一个time()格式。</p><h3 id="gmtime-localtime"><a href="#gmtime-localtime" class="headerlink" title="gmtime localtime"></a>gmtime localtime</h3><p>gmtime返回UTC时间，localtime返回本地时间。</p><p>他们两个都有一个可选参数，传递的是time()返回的格式数据，如果传递0，那么会获取到新世纪元的时间起始点，一般是从1970年开始的。</p><h3 id="asctime-ctime"><a href="#asctime-ctime" class="headerlink" title="asctime ctime"></a>asctime ctime</h3><p>asctime返回类似<code>Sun Jun 20 23:21:05 1993</code>这样的字符串，如果没有参数，默认使用localtime的返回值。</p><p>ctime返回和asctime类似，只不过接收的参数是time函数返回的格式，默认使用time的返回值。</p><h3 id="strptime-strftime"><a href="#strptime-strftime" class="headerlink" title="strptime strftime"></a>strptime strftime</h3><p>两个函数用于格式化和反格式化时间。strptime返回接收格式化时间，返回<code>struct_time</code>格式，strftime接受<code>struct_time</code>，返回一个字符串表示。</p><p>常用的格式化符号有： %Y %m %d %H %M %S(分别表示年月日时分秒)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = strftime(&quot;%Y%m%d%H%M%S&quot;, localtime()) #其中第二个参数默认是localtime，a打印的结果是20180716181239</span><br><span class="line">b = strptime(a, &quot;%Y%m%d%H%M%S&quot;) #返回一个struct_time类型数据</span><br></pre></td></tr></table></figure><h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><p>datetime模块包含了date, time, datetime, timedelta, tzinfo, timezone几个类。</p><p>其中timedelta是用于datetime其它模块经过计算后的结果，或者作为中间件进行计算。</p><p>timedelta虽然可以接受days,hours,minutes,seconds等作为参数，但是只有days,seconds,microseconds可以直接使用，其中hours,minutes都被转换为seconds了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">now = datetime.now() #获取当前时间，类似datetime.today()和datetime.fromtimestamp(time.time())，当然datetime也支持构造函数创建对象，可以指定特定的时间点。</span><br><span class="line">per = datetime.now().replace(day=1) #replace会返回一个新的datetime对象</span><br><span class="line"></span><br><span class="line">d = now - per #返回的是timedelta对象，(days, seconds, microseconds)</span><br><span class="line">d = now.date() - per.date() #返回timedelta对象，(days)，其中now.date()返回date对象，now.time()返回time对象</span><br><span class="line"></span><br><span class="line">now &gt; per #返回True</span><br><span class="line">now.time() &gt; per.time() #返回True</span><br></pre></td></tr></table></figure><blockquote><p>注意，datetime.time对象不支持加减操作，但是支持大小比较操作。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datetime.now().strftime(&quot;time format string&quot;) #类似time的strftime</span><br><span class="line">datetime.strptime(datetime_obj, &quot;time format string&quot;) #这个是类函数，功能类似time的strptime</span><br></pre></td></tr></table></figure><h2 id="calender-模块"><a href="#calender-模块" class="headerlink" title="calender 模块"></a>calender 模块</h2><h2 id="第三方库dateutil"><a href="#第三方库dateutil" class="headerlink" title="第三方库dateutil"></a>第三方库dateutil</h2><p><a href="https://pypi.org/project/python-dateutil/" target="_blank" rel="noopener">https://pypi.org/project/python-dateutil/</a></p><p><a href="https://dateutil.readthedocs.io/en/stable/" target="_blank" rel="noopener">https://dateutil.readthedocs.io/en/stable/</a></p><h2 id="个人模块"><a href="#个人模块" class="headerlink" title="个人模块"></a>个人模块</h2><p>python的时间处理模块中，可以对hour,day进行加减，但是没有对月进行处理，比如计算当前月的前一个月，前五个月的情况，没有处理，个人单独写了一个函数可以处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def relative_months(obj, months=0):</span><br><span class="line">    year, month, day = obj.year, obj.month, obj.day</span><br><span class="line">    year_delta, month = divmod(obj.month + months, 12)</span><br><span class="line">    year = obj.year + year_delta</span><br><span class="line">    if month == 0:</span><br><span class="line">        year, month = year - 1, 12</span><br><span class="line"></span><br><span class="line">    if month in [2, 4, 6, 9, 11] and obj.day == 31:</span><br><span class="line">        day = 30</span><br><span class="line">    if month == 2 and obj.day &gt; 29:</span><br><span class="line">        try:</span><br><span class="line">            datetime(year, 2, 29)</span><br><span class="line">            day = 29</span><br><span class="line">        except:</span><br><span class="line">            day = 28</span><br><span class="line"></span><br><span class="line">    return datetime(year, month, day, obj.hour, obj.minute)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-环境变量</title>
      <link href="/2018/07/13/Linux/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
      <url>/2018/07/13/Linux/Linux-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<a id="more"></a><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以修改/etc/profile下面，这个是针对全局用户的，如果想针对某个用户修改，比如root用户，可以使用/root/.bashrc文件</p><h2 id="配置格式"><a href="#配置格式" class="headerlink" title="配置格式"></a>配置格式</h2><p>文件里面的配置格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/path/to/java</span><br><span class="line">export PATH=/path/to/add:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数据库-SQL语句</title>
      <link href="/2018/07/13/Database/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E5%8F%A5/"/>
      <url>/2018/07/13/Database/%E6%95%B0%E6%8D%AE%E5%BA%93-SQL%E8%AF%AD%E5%8F%A5/</url>
      <content type="html"><![CDATA[<p>本文主要记录了SQL语句的使用。</p><a id="more"></a><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO test (areaid, datefmt, client, mac) VALUES (1, 20180911, 100, &apos;x&apos;), (1, 20180911, 100, &apos;y&apos;) #插入多组数据之间用,分割</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">order by</span><br></pre></td></tr></table></figure><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组的原则是先按照条件选取数据，然后分组，然后统计数据。</p><p>比如现在有下面的一张表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">areaid client tx</span><br><span class="line">1   a   100</span><br><span class="line">1   a   200</span><br><span class="line">1   b   150</span><br><span class="line">2   c   200</span><br></pre></td></tr></table></figure><p>现在通过下面的语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT areaid, count(distinct client) as count, sum(tx) as tx GROUP BY areaid</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   2   450</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>注意上面对client使用的distinct去重，如果不用去重得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   3   450</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>如果使用下面的语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select areaid, count(client), sum(tx) from test group by areaid, client;</span><br></pre></td></tr></table></figure><p>得到的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">areaid count tx</span><br><span class="line">1   2   300</span><br><span class="line">1   1   150</span><br><span class="line">2   1   200</span><br></pre></td></tr></table></figure><p>也就是先按照了areaid分组，在按照了client进行分组，然后在统计。</p><h3 id="处理分组内容"><a href="#处理分组内容" class="headerlink" title="处理分组内容"></a>处理分组内容</h3><p>假设有下面一张表(test)。</p><p>其中areaid是一个整形的类似ID的数据，datefmt是日期的整形表示，比如20180711表示的是2018年7月11日。</p><p><img src="group1.png" alt="group1"></p><p>需要选取areaid, datefmt，datefmt统计到月，并且按照月areaid, datefmt进行分组，统计client在每个areaid的每月的总数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select areaid, datefmt/100 as datefmt, sum(client) from test group by areaid, datefmt/100; #如果需要转换类型，使用下面的语句</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select areaid, int(datefmt/100) as datefmt, sum(client) from test group by areaid, int(datefmt/100);</span><br></pre></td></tr></table></figure><p>统计结果：</p><p><img src="group1_result.png" alt="group1_result"></p>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-定时任务</title>
      <link href="/2018/07/12/Linux/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2018/07/12/Linux/Linux-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      <content type="html"><![CDATA[<p>本文主要记录了Linux的定时任务，比如crontab。</p><a id="more"></a><h2 id="Crontab"><a href="#Crontab" class="headerlink" title="Crontab"></a>Crontab</h2><p>我们可以通过crontab命令来配置我们的定时任务，比如每小时，每天，每隔多少分钟(小时，天，周)，每周的第几天等等，有点类似Jenkins上配置定时任务的功能，语法也类似。</p><h3 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h3><p>首先通过命令<code>crontab -e</code>会进入crontab的编辑界面，里面的操作就类似于使用vim编辑文件一样，只是需要遵守格式即可，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 * * * * task #没小时的10分钟的时候执行task</span><br><span class="line">30 10 * * * task #每天的10:30分执行task</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontal -l #查看crontab里面配置的定时任务</span><br></pre></td></tr></table></figure><h3 id="任务跟踪"><a href="#任务跟踪" class="headerlink" title="任务跟踪"></a>任务跟踪</h3><p>可以通过下面的命令查看crontab的日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tail -n 100 /var/spool/mail/root #这个会把crontab的运行日志记录在里面，当然这里使用tail命令只查看了最后的100行</span><br><span class="line"></span><br><span class="line">tail -f /var/log/cron #这个是查看crontab执行了哪些任务的跟踪</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-文件处理</title>
      <link href="/2018/07/12/Linux/Linux-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2018/07/12/Linux/Linux-%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>本文主要记录了Linux的文件处理，比如压缩解压等。</p><a id="more"></a><h2 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h2><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zip -r test.zip test #压缩test，压缩文件名为test.zip，另外压缩文件解压后就和test完全一致，没有里面在嵌套一层的说法</span><br><span class="line">zip -t test.zip #在不解压的情况下查看压缩文件的内容</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>大数据-入门</title>
      <link href="/2018/07/12/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E5%85%A5%E9%97%A8/"/>
      <url>/2018/07/12/BigData/%E5%A4%A7%E6%95%B0%E6%8D%AE-%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>由于对Python比较熟悉，公司要使用Python进行大数据处理，本文记录了处理大数据过程的内容，内容比较杂乱，后期会单独整理成独立的文章。</p><a id="more"></a><h2 id="名词与理论"><a href="#名词与理论" class="headerlink" title="名词与理论"></a>名词与理论</h2><h3 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h3><ol><li>RDD: Resilient Distributed Dataset, 弹性式分布数据集</li><li>HDFS: Hadoop Distributed File System</li><li>JDBC: Java DataBase Connectivity, java数据库连接</li></ol><h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><h4 id="spark几个概念"><a href="#spark几个概念" class="headerlink" title="spark几个概念"></a>spark几个概念</h4><p>spark是一个快速的，多用途的集群计算系统。</p><p>driver就是驱动程序，简单点说就是执行submit脚本的那个进程，executor就是执行机，执行具体的运算，里面有task，task就是实际的任务，executor可能产生多个task，这些task对应一个应用(就是一个SparkContext)，但是一个executor里面有多个task，有可能会对应其它的应用。</p><h4 id="yarn的几个概念"><a href="#yarn的几个概念" class="headerlink" title="yarn的几个概念"></a>yarn的几个概念</h4><p><a href="https://www.cnblogs.com/xubiao/p/5689427.html" target="_blank" rel="noopener">https://www.cnblogs.com/xubiao/p/5689427.html</a></p><p>ResourceManager, ApplicationManager, NodeManager, Container</p><h4 id="hadoop几个概念"><a href="#hadoop几个概念" class="headerlink" title="hadoop几个概念"></a>hadoop几个概念</h4><p><a href="https://www.cnblogs.com/yjd_hycf_space/p/6735290.html" target="_blank" rel="noopener">https://www.cnblogs.com/yjd_hycf_space/p/6735290.html</a></p><p>NameNode, DataNode</p><h4 id="spark与yarn"><a href="#spark与yarn" class="headerlink" title="spark与yarn"></a>spark与yarn</h4><p>使用pyspark进入shell的时候，yarn的webui(8088)里面是看不见pyspark的，因为没有使用yarn模式，当时用pyspark –master yarn的时候，yarn的webui里面可以看见一个应用程序启动了。证明spark以yarn方式执行，yarn把一个spark任务(job)当成了一个application，当然就会有对应的RM,AM,NM,Container的交互，spark也会有driver,executor的交互。</p><p>8088就是yarn的RM界面，如果启动了一个Application，可以查看AM的跟踪界面。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>数据库事务：就是针对一系列的sql语句要么都执行成功，要么都不执行，比如银行转账，需要执行两条sql语句，一条减少转出人的账户，一条增加转入人的账户，这两条必须同时执行否则就会出错，cursor是把sql的操作放到缓存里面，如果不执行commit，是不会提交事务的，如果任意一个失败，可以使用rollback进行事物回滚，大家都不执行。</p><p>另外，记住cursor是操作的缓存，比如select语句以后，选出的内容都存放在缓冲里面，如果使用fetchall，那么取得全部数据，这时候在用fetch等一系列函数将获取不到任何数据了，因为fetchall已经把缓存里面的数据全部拿走了，当然如果使用两次的fetchone，他们获得的是两次不同的数据，也就是按次序获取如果中间再次使用了select语句，那么缓存内容被更新，当然这里不单单指select语句了，执行了任何语句，缓冲内容都会被更心，比如开始执行了select语句，马上执行insert语句，那么通过fetch函数是获取不到任何内容的cursor不论关闭还是打开，只要connection没有关闭，那么cursor都可以获取到本轮修改的内容，而不是原始数据库的内容了，如果执行了commit，此时数据库才会被修改，也就是说，没有必要关闭cursor，直接关闭connection即可。同理，如果没有commit，使用了rollback，那么重新select的数据就和数据库一致了。</p><p>其实也有个问题就是，如果有改动的操作，一定要commit后在使用select去查。另外如果一条insert，然后马上使用delete删除与此insert有相同的条件，那么数据库里面满足条件的和刚刚insert满足条件的都会被删除，当然你必须执行commit后才能提交到数据库中。</p><h2 id="几幅图片"><a href="#几幅图片" class="headerlink" title="几幅图片"></a>几幅图片</h2><h3 id="yarn相关"><a href="#yarn相关" class="headerlink" title="yarn相关"></a>yarn相关</h3><p><img src="yarn.png" alt="yarn"></p><h3 id="spark相关"><a href="#spark相关" class="headerlink" title="spark相关"></a>spark相关</h3><p><img src="spark1.png" alt="spark1"></p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Python-Spark"><a href="#Python-Spark" class="headerlink" title="Python+Spark"></a>Python+Spark</h3><ol><li><a href="http://spark.apache.org/downloads.html" target="_blank" rel="noopener">http://spark.apache.org/downloads.html</a> 官网下载好压缩包，直接解压后，配置好SPARK_HOME到根目录下，然后把%SPARK_HOME%\bin加入到Path环境目录下，就可以通过pyspark命令启动交互式shell了。</li></ol><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><ol><li>此时不应有JAVA….之类的错误</li></ol><blockquote><p>请检查JAVA_HOME JRE_HOME的环境变量是否包含了(x86)这种格式，spark不识别括号，所以需要重新配置这个环境变量，主要不要有括号，比如安装到64位的安装目录下，获取重新安装JAVA到其它文件夹</p></blockquote><ol start="2"><li>如果启动过程中发现报错的信息有关于hadoop相关的</li></ol><blockquote><p>主要是没有hadoop相关的配置，由于在前面选择下载spark的时候，选择的是Pre-builtfor Apache-Hadoop2.7 and later，所以我们需要去下载Hadoop2.7或以后的版本，下载好后，同样的需要配置HADOOP_HOME，并且把HADOOP_HOME\bin加入到环境变量中，重新再次启动，关于hadoop的错误提示应该就没有了。</p></blockquote><blockquote><blockquote><p>注意hadhoop spark的环境变量的配置路径里面不能有空格，括号，比如Programe file这里有空格，可以是使用PROGRA~1代替</p></blockquote></blockquote><blockquote><blockquote><p>如果提示找不到winutils， 可以到 <a href="https://github.com/steveloughran/winutils" target="_blank" rel="noopener">https://github.com/steveloughran/winutils</a> 下载对应的winutils放到hadoop的bin目录下，重新执行即可</p></blockquote></blockquote><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>环境都都配置好后，通过下面的命令检查环境是否正常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-shell</span><br></pre></td></tr></table></figure><p>可以打开spark-shell.cmd查看里面的内容，其中<code>%~dp0</code>表示当前文件所在目录, <code>%*</code>表示传递过来的参数</p><h3 id="windows配置IP对应域名"><a href="#windows配置IP对应域名" class="headerlink" title="windows配置IP对应域名"></a>windows配置IP对应域名</h3><p>类似Linux下/etc/host文件，Windows是在C:\Windows\System32\drivers\etc这个目录下，配置格式大概如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.20.115 ism</span><br></pre></td></tr></table></figure><h2 id="Spark概念"><a href="#Spark概念" class="headerlink" title="Spark概念"></a>Spark概念</h2><p>Spark里面有一些概念在下面进行记录。</p><h3 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h3><p>这个是action里面的一个函数， 里面的withReplacement是指放回抽样(True)和不放回抽样(False)，比如有5个不同颜色的小球，每次抽取两个，放回抽样，类似于先抽取一个，比如抽到白色，然后放回，在抽取一个这次有可能还是抽到白球，而不放回抽样，就是先抽取一个，比如抽取到白球，这个球不会放回，里面只有4个球，在抽取一个，也就是两次的结果是肯定不会一样的</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In general, configuration values explicitly set on a SparkConf take the highest precedence, then flags passed to spark-submit, then values in the defaults file. If you are ever unclear where configuration options are coming from, you can print out fine-grained debugging information by running spark-submit with the --verbose option</span><br></pre></td></tr></table></figure><h2 id="Pyspark"><a href="#Pyspark" class="headerlink" title="Pyspark"></a>Pyspark</h2><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>下面的是先记录下来，以后作详细的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">spark.read.format(&quot;jdbc&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).load()</span><br><span class="line"></span><br><span class="line">a.write.format(&quot;jdbc&quot;).mode(&quot;append&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).save()</span><br><span class="line"></span><br><span class="line">lines = sc.textFile(&quot;file:/C:/Users/sk-leilin/Desktop/test.txt&quot;)</span><br><span class="line"></span><br><span class="line">db.collection.find(query, projection);</span><br><span class="line">db.collection.find().pretty();</span><br><span class="line">db.collection.findOne();</span><br><span class="line"></span><br><span class="line">sc = spark.sparkContext</span><br><span class="line">lines = sc.textFile(&quot;file:/C:/Users/sk-leilin/Desktop/test.txt&quot;)</span><br><span class="line">parts = line.map(lambda x: x.split(&apos;,&apos;))</span><br><span class="line">data = spark.createDataFrame(parts, [&quot;language&quot;, &quot;salary&quot;])</span><br><span class="line">data.write.format(&quot;jdbc&quot;).mode(&quot;append&quot;).option(&quot;url&quot;, &quot;jdbc:postgresql://127.0.0.1:5432/postgres&quot;).option(&quot;dbtable&quot;, &quot;tbone&quot;).option(&quot;user&quot;, &quot;postgres&quot;).option(&quot;passowrd&quot;, &quot;123.com&quot;).save()</span><br></pre></td></tr></table></figure><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="hdfs"><a href="#hdfs" class="headerlink" title="hdfs"></a>hdfs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdfs dfs -ls /tmp #查看</span><br><span class="line">hdfs dfs -put test.txt2 /tmp/ #上传本地test.txt2到hdfs的tmp目录</span><br></pre></td></tr></table></figure><p>动态分区问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hive.exec.dynamic.partition=true;</span><br><span class="line">set hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure><h3 id="database"><a href="#database" class="headerlink" title="database"></a>database</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">use db;</span><br><span class="line">show tables;</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">show create table test_table; #查看hive存储位置，里面有一个LOCATION字段</span><br><span class="line">desc test_table; #查看表结构，(desc 是 description)</span><br><span class="line"></span><br><span class="line">select * from tb limit 10;</span><br></pre></td></tr></table></figure><h3 id="conda"><a href="#conda" class="headerlink" title="conda"></a>conda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">conda list #列出当前环境的安装的库</span><br><span class="line">conda info --env 查看已有的环境 #或者使用conda env list</span><br><span class="line">conda create --name testpy python=3.4 创建一个新的基于3.4的环境</span><br><span class="line">conda install numpy</span><br><span class="line">conda list -n testpy #查看testpy下的安装库</span><br><span class="line">conda install -n testpy numpy #在testpy下安装numpy</span><br><span class="line">conda remove -n testpy numbpy #移除testpy下的numpy</span><br><span class="line">conda update numpy/python/conda/anaconda #由于conda把所有的都当成的包的方式管理，这里也可以把python当成包来管理</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ #添加Anaconda的TUNA镜像</span><br><span class="line">conda config --set show_channel_urls yes # 设置搜索时显示通道地址</span><br><span class="line">conda remove -n testpy --all #移除testpy环境，默认是在anaconda的envs文件夹下面</span><br><span class="line">conda config --show #查看配置</span><br><span class="line">conda create -n testpy --clone root #从root直接克隆一个环境叫testpy</span><br><span class="line">source activate testpy #激活testpy环境</span><br><span class="line">source deactivate #退出</span><br></pre></td></tr></table></figure><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn logs -applicationId application_1530842592838_0023 #查看指定application的log</span><br></pre></td></tr></table></figure><h3 id="pyspark"><a href="#pyspark" class="headerlink" title="pyspark"></a>pyspark</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master yarn --num-executors 2 --executor-memory 2g</span><br></pre></td></tr></table></figure><h3 id="java"><a href="#java" class="headerlink" title="java"></a>java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps #查看jvm进程</span><br></pre></td></tr></table></figure><h3 id="其它-1"><a href="#其它-1" class="headerlink" title="其它"></a>其它</h3><p>下面的是先记录下来，以后作详细的分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --jars ./postgresql-42.2.2.jar --executor-memory 2G --num-executors 4 --master yarn --deploy-mode client --conf spark.yarn.appMasterEnv.PYSPARK_PYTHON=/opt/anaconda3/bin/python ./pgsql.py</span><br></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8088端口: 可以查看运行的app</span><br></pre></td></tr></table></figure><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>虽然目前很多概念性的理论东西不是很熟悉，但是先熟悉下环境的配置。</p><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装hadoop</h3><h2 id="spark编程"><a href="#spark编程" class="headerlink" title="spark编程"></a>spark编程</h2><h3 id="pyspark-shell"><a href="#pyspark-shell" class="headerlink" title="pyspark-shell"></a>pyspark-shell</h3><p>通过 <code>pyspark --master yarn</code>可以通过使用yarn的模式进入python的shell。里面默认创建了一个SparkSession对象叫spark，shell里面可以直接使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sc = spark.sparkContext #通过session获取SparkContext对象</span><br><span class="line"></span><br><span class="line">distData = sc.parallelize(range(1, 6)) #根据python的集合创建一个RDD</span><br><span class="line"></span><br><span class="line">temp = distData.collect() #执行一次任务，获得的temp是python的一个列表集合</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> bigdata </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Tool-docker</title>
      <link href="/2018/07/04/Tools/Tool-docker/"/>
      <url>/2018/07/04/Tools/Tool-docker/</url>
      <content type="html"><![CDATA[<p>本文主要记录了docker的基本使用。</p><a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="CentOS下安装"><a href="#CentOS下安装" class="headerlink" title="CentOS下安装"></a>CentOS下安装</h3><h4 id="直接通过yum的方式安装"><a href="#直接通过yum的方式安装" class="headerlink" title="直接通过yum的方式安装"></a>直接通过yum的方式安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum update #确保是最新的yum源</span><br><span class="line">yum -y install docker-io #这里-y参数是在yum里面会有各种提示y/d/n等你输入，如果这里-y参数提供了，那么默认输入y</span><br><span class="line">service docker start #启动docker服务</span><br><span class="line"></span><br><span class="line">docker run hello-world #可以测试一个helloworld程序，这个默认是不存在的，会在docker仓库拉取一次</span><br></pre></td></tr></table></figure><blockquote><p>如果CentOS7里面使用<code>service</code>命令启动docker报错，可以使用<code>systemctl start docker</code>的方式查看是否可以启动。</p></blockquote><blockquote><p>如果CentOS7里面启动docker报错，可以试着重新安装<code>yum install docker-engine</code>这个即可，安装之前卸载掉前面安装的内容<code>yum remove docker;yum remove docker-selinux</code>。</p></blockquote><h5 id="服务相关几个命令-以docker服务为例-："><a href="#服务相关几个命令-以docker服务为例-：" class="headerlink" title="服务相关几个命令(以docker服务为例)："></a>服务相关几个命令(以docker服务为例)：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">启动docker：systemctl start docker</span><br><span class="line">停止docker：systemctl stop docker</span><br><span class="line">重启docker：systemctl restart docker</span><br><span class="line">查看docker状态：systemctl status docker</span><br><span class="line">开机启动：systemctl enable docker</span><br><span class="line"></span><br><span class="line">[root@localhost system]# systemctl list-unit-files | grep docker</span><br><span class="line">docker-cleanup.service                        disabled</span><br><span class="line">docker-storage-setup.service                  disabled</span><br><span class="line">docker.service                                disabled</span><br><span class="line">docker-cleanup.timer                          disabled</span><br><span class="line">[root@localhost system]# </span><br><span class="line">[root@localhost system]# </span><br><span class="line">[root@localhost system]# systemctl cat docker.service #这里可以查看服务配置文件位置</span><br></pre></td></tr></table></figure><h4 id="镜像源的配置"><a href="#镜像源的配置" class="headerlink" title="镜像源的配置"></a>镜像源的配置</h4><p>由于国外镜像不能访问或者很慢，可以编辑<code>/etc/docker/daemon.json</code>这个文件，配置内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当然也可以配置&quot;insecure-registries&quot;:[&quot;10.10.30.240:5000&quot;]为自己的私人仓库地址</span><br></pre></td></tr></table></figure><blockquote><p>注意如果在CentOS7里面，配置这个不生效的情况，可以查看<code>/etc/sysconfig/docker</code>这个文件，里面让<code>Do not add registries in this file anymore. Use /etc/containers/registries.conf</code>这样做，我们查看<code>/etc/containers/registries.conf</code>这个文件，可以看到<code>registries.search</code>这个字段，我们增加我们自己的仓库即可。比如增加阿里云的仓库<code>r6w9c7qa.mirror.aliyuncs.com/library</code>。</p></blockquote><h2 id="本地仓库搭建"><a href="#本地仓库搭建" class="headerlink" title="本地仓库搭建"></a>本地仓库搭建</h2><p>有时候内网无法访问外网，通过设置http代理的方式是不能解决docker pull镜像的，所以可以在一台可以访问外网的机器上搭建自己的私有仓库，然后内网去拉去这里面的镜像即可。</p><h3 id="CentOS7的搭建"><a href="#CentOS7的搭建" class="headerlink" title="CentOS7的搭建"></a>CentOS7的搭建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry</span><br><span class="line">docker run -d -p 5000:5000 -v /opt/registry:/var/lib/registry --restart=always --name registry registry</span><br><span class="line">docker ps #可以查看刚刚启动的registry，通过范文`http://IP:5000/v2/_catalog`查看仓库已有的镜像，如果是新建的，一般是空的</span><br><span class="line">docker pull busybox #拉取一个busybox到本地，这里使用busybox进行测试，因为这个很小</span><br><span class="line">docker images #查看拉取得镜像</span><br><span class="line">docker tag busybox registry:5000/busybox #给自己的镜像取个名字，加入tag，这里只是多了一个镜像，busybox这个原始镜像仍然还在</span><br></pre></td></tr></table></figure><blockquote><p>注意上面说的tag步骤，说法不是很准确，如果给一个镜像修改自己的tag，完整的是<code>docker tag busybox new_name:new_tag</code>，其中<code>new_name:new_tag</code>里面的new_name是取得新的名字，比如上例中的<code>registry:5000/busybox</code>，这只是一个名字，加入的tag是默认的latest。</p></blockquote><p>修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@Jenkins:~# cat /etc/docker/daemon.json </span><br><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;registry:5000&quot;] &#125;</span><br></pre></td></tr></table></figure><p>查看仓库的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET http://registry:5000/v2/_catalog</span><br></pre></td></tr></table></figure><p>内网机器拉取镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker #查看docker服务的配置文件，一般是/usr/lib/systemd/system/docker.service，在这个文件的ExecStart字段里面增加--add-registry=registry:5000 --insecure-registry=registry:5000</span><br><span class="line"></span><br><span class="line">systemctl start docker #启动docker服务</span><br><span class="line"></span><br><span class="line">docker pull busybox #拉取本地镜像，这个速度很快的</span><br></pre></td></tr></table></figure><blockquote><p>注意了， registry:5000上面的配置中registry都必须是仓库的IP地址，包括<code>docker tag busybox registry:5000/busybox</code>这句，里面也是固定的，否则通过<code>docker push</code>是push到了docker.io里面去的。</p></blockquote><blockquote><p>docker run里面的参数说明：-d -p -v –restart –name</p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="帮助信息"><a href="#帮助信息" class="headerlink" title="帮助信息"></a>帮助信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker --help #可以查看docker命令的帮助</span><br><span class="line">docker stats --help #可以查看stats子命令的帮助</span><br><span class="line"></span><br><span class="line">docker info #查看docker环境的配置信息</span><br></pre></td></tr></table></figure><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi imagename #如果镜像容器已经运行，需要先删除容器</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Linux-网络配置</title>
      <link href="/2018/07/04/Linux/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/07/04/Linux/Linux-%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>主要记录了Linux网络相关的配置，比如IP地址，防火墙等。</p><a id="more"></a><h2 id="IP配置"><a href="#IP配置" class="headerlink" title="IP配置"></a>IP配置</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">首先编辑文件：vim etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">device=eth0</span><br><span class="line">bootproto=dhcp #如果需要手动配置IP地址，这里配置为none</span><br><span class="line">onboot=yes #是否随系统启动</span><br><span class="line">hwaddr=09:0a #mac地址</span><br><span class="line">IPADDR=10.0.1.27  #IP地址</span><br><span class="line">NETMASK=255.255.255.0  </span><br><span class="line">GATEWAY=10.0.1.1</span><br><span class="line">最后重启服务：service network restart</span><br></pre></td></tr></table></figure><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><h3 id="CentOS-1"><a href="#CentOS-1" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑文件：vim etc/sysconfig/network-scripts/route-eth0</span><br><span class="line">格式为：10.0.0.0/8 via 192.168.53.1，其中192.168.53.1这个是网关</span><br></pre></td></tr></table></figure><h2 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h2><h3 id="CentOS-2"><a href="#CentOS-2" class="headerlink" title="CentOS"></a>CentOS</h3><p>如果遇到root用户不能登陆的情况，修改<code>/etc/ssh/sshd_config</code>文件，取消<code>PermitRootLogin</code>这个参数的注释。</p>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
